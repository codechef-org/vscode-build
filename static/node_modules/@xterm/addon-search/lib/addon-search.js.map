{"version":3,"file":"addon-search.js","mappings":"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","sources":["webpack://SearchAddon/webpack/universalModuleDefinition","webpack://SearchAddon/../../out/vs/base/common/arrays.js","webpack://SearchAddon/../../out/vs/base/common/arraysFind.js","webpack://SearchAddon/../../out/vs/base/common/collections.js","webpack://SearchAddon/../../out/vs/base/common/errors.js","webpack://SearchAddon/../../out/vs/base/common/event.js","webpack://SearchAddon/../../out/vs/base/common/functional.js","webpack://SearchAddon/../../out/vs/base/common/iterator.js","webpack://SearchAddon/../../out/vs/base/common/lifecycle.js","webpack://SearchAddon/../../out/vs/base/common/linkedList.js","webpack://SearchAddon/../../out/vs/base/common/map.js","webpack://SearchAddon/../../out/vs/base/common/stopwatch.js","webpack://SearchAddon/webpack/bootstrap","webpack://SearchAddon/./src/SearchAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SearchAddon\"] = factory();\n\telse\n\t\troot[\"SearchAddon\"] = factory();\n})(globalThis, () => {\nreturn ","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Permutation = exports.CallbackIterable = exports.ArrayQueue = exports.booleanComparator = exports.numberComparator = exports.CompareResult = void 0;\nexports.tail = tail;\nexports.tail2 = tail2;\nexports.equals = equals;\nexports.removeFastWithoutKeepingOrder = removeFastWithoutKeepingOrder;\nexports.binarySearch = binarySearch;\nexports.binarySearch2 = binarySearch2;\nexports.quickSelect = quickSelect;\nexports.groupBy = groupBy;\nexports.groupAdjacentBy = groupAdjacentBy;\nexports.forEachAdjacent = forEachAdjacent;\nexports.forEachWithNeighbors = forEachWithNeighbors;\nexports.sortedDiff = sortedDiff;\nexports.delta = delta;\nexports.top = top;\nexports.topAsync = topAsync;\nexports.coalesce = coalesce;\nexports.coalesceInPlace = coalesceInPlace;\nexports.move = move;\nexports.isFalsyOrEmpty = isFalsyOrEmpty;\nexports.isNonEmptyArray = isNonEmptyArray;\nexports.distinct = distinct;\nexports.uniqueFilter = uniqueFilter;\nexports.firstOrDefault = firstOrDefault;\nexports.lastOrDefault = lastOrDefault;\nexports.commonPrefixLength = commonPrefixLength;\nexports.range = range;\nexports.index = index;\nexports.insert = insert;\nexports.remove = remove;\nexports.arrayInsert = arrayInsert;\nexports.shuffle = shuffle;\nexports.pushToStart = pushToStart;\nexports.pushToEnd = pushToEnd;\nexports.pushMany = pushMany;\nexports.mapArrayOrNot = mapArrayOrNot;\nexports.asArray = asArray;\nexports.getRandomElement = getRandomElement;\nexports.insertInto = insertInto;\nexports.splice = splice;\nexports.compareBy = compareBy;\nexports.tieBreakComparators = tieBreakComparators;\nexports.reverseOrder = reverseOrder;\nconst errors_1 = require(\"vs/base/common/errors\");\nconst arraysFind_1 = require(\"./arraysFind\");\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nfunction tail(array, n = 0) {\n    return array[array.length - (1 + n)];\n}\nfunction tail2(arr) {\n    if (arr.length === 0) {\n        throw new Error('Invalid tail call');\n    }\n    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nfunction equals(one, other, itemEquals = (a, b) => a === b) {\n    if (one === other) {\n        return true;\n    }\n    if (!one || !other) {\n        return false;\n    }\n    if (one.length !== other.length) {\n        return false;\n    }\n    for (let i = 0, len = one.length; i < len; i++) {\n        if (!itemEquals(one[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nfunction removeFastWithoutKeepingOrder(array, index) {\n    const last = array.length - 1;\n    if (index < last) {\n        array[index] = array[last];\n    }\n    array.pop();\n}\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nfunction binarySearch(array, key, comparator) {\n    return binarySearch2(array.length, i => comparator(array[i], key));\n}\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nfunction binarySearch2(length, compareToKey) {\n    let low = 0, high = length - 1;\n    while (low <= high) {\n        const mid = ((low + high) / 2) | 0;\n        const comp = compareToKey(mid);\n        if (comp < 0) {\n            low = mid + 1;\n        }\n        else if (comp > 0) {\n            high = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -(low + 1);\n}\nfunction quickSelect(nth, data, compare) {\n    nth = nth | 0;\n    if (nth >= data.length) {\n        throw new TypeError('invalid index');\n    }\n    const pivotValue = data[Math.floor(data.length * Math.random())];\n    const lower = [];\n    const higher = [];\n    const pivots = [];\n    for (const value of data) {\n        const val = compare(value, pivotValue);\n        if (val < 0) {\n            lower.push(value);\n        }\n        else if (val > 0) {\n            higher.push(value);\n        }\n        else {\n            pivots.push(value);\n        }\n    }\n    if (nth < lower.length) {\n        return quickSelect(nth, lower, compare);\n    }\n    else if (nth < lower.length + pivots.length) {\n        return pivots[0];\n    }\n    else {\n        return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n    }\n}\nfunction groupBy(data, compare) {\n    const result = [];\n    let currentGroup = undefined;\n    for (const element of data.slice(0).sort(compare)) {\n        if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n            currentGroup = [element];\n            result.push(currentGroup);\n        }\n        else {\n            currentGroup.push(element);\n        }\n    }\n    return result;\n}\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nfunction* groupAdjacentBy(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nfunction forEachAdjacent(arr, f) {\n    for (let i = 0; i <= arr.length; i++) {\n        f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n    }\n}\nfunction forEachWithNeighbors(arr, f) {\n    for (let i = 0; i < arr.length; i++) {\n        f(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n    }\n}\n/**\n * Diffs two *sorted* arrays and computes the splices which apply the diff.\n */\nfunction sortedDiff(before, after, compare) {\n    const result = [];\n    function pushSplice(start, deleteCount, toInsert) {\n        if (deleteCount === 0 && toInsert.length === 0) {\n            return;\n        }\n        const latest = result[result.length - 1];\n        if (latest && latest.start + latest.deleteCount === start) {\n            latest.deleteCount += deleteCount;\n            latest.toInsert.push(...toInsert);\n        }\n        else {\n            result.push({ start, deleteCount, toInsert });\n        }\n    }\n    let beforeIdx = 0;\n    let afterIdx = 0;\n    while (true) {\n        if (beforeIdx === before.length) {\n            pushSplice(beforeIdx, 0, after.slice(afterIdx));\n            break;\n        }\n        if (afterIdx === after.length) {\n            pushSplice(beforeIdx, before.length - beforeIdx, []);\n            break;\n        }\n        const beforeElement = before[beforeIdx];\n        const afterElement = after[afterIdx];\n        const n = compare(beforeElement, afterElement);\n        if (n === 0) {\n            // equal\n            beforeIdx += 1;\n            afterIdx += 1;\n        }\n        else if (n < 0) {\n            // beforeElement is smaller -> before element removed\n            pushSplice(beforeIdx, 1, []);\n            beforeIdx += 1;\n        }\n        else if (n > 0) {\n            // beforeElement is greater -> after element added\n            pushSplice(beforeIdx, 0, [afterElement]);\n            afterIdx += 1;\n        }\n    }\n    return result;\n}\n/**\n * Takes two *sorted* arrays and computes their delta (removed, added elements).\n * Finishes in `Math.min(before.length, after.length)` steps.\n */\nfunction delta(before, after, compare) {\n    const splices = sortedDiff(before, after, compare);\n    const removed = [];\n    const added = [];\n    for (const splice of splices) {\n        removed.push(...before.slice(splice.start, splice.start + splice.deleteCount));\n        added.push(...splice.toInsert);\n    }\n    return { removed, added };\n}\n/**\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @return The first n elements from array when sorted with compare.\n */\nfunction top(array, compare, n) {\n    if (n === 0) {\n        return [];\n    }\n    const result = array.slice(0, n).sort(compare);\n    topStep(array, compare, result, n, array.length);\n    return result;\n}\n/**\n * Asynchronous variant of `top()` allowing for splitting up work in batches between which the event loop can run.\n *\n * Returns the top N elements from the array.\n *\n * Faster than sorting the entire array when the array is a lot larger than N.\n *\n * @param array The unsorted array.\n * @param compare A sort function for the elements.\n * @param n The number of elements to return.\n * @param batch The number of elements to examine before yielding to the event loop.\n * @return The first n elements from array when sorted with compare.\n */\nfunction topAsync(array, compare, n, batch, token) {\n    if (n === 0) {\n        return Promise.resolve([]);\n    }\n    return new Promise((resolve, reject) => {\n        (async () => {\n            const o = array.length;\n            const result = array.slice(0, n).sort(compare);\n            for (let i = n, m = Math.min(n + batch, o); i < o; i = m, m = Math.min(m + batch, o)) {\n                if (i > n) {\n                    await new Promise(resolve => setTimeout(resolve)); // any other delay function would starve I/O\n                }\n                if (token && token.isCancellationRequested) {\n                    throw new errors_1.CancellationError();\n                }\n                topStep(array, compare, result, i, m);\n            }\n            return result;\n        })()\n            .then(resolve, reject);\n    });\n}\nfunction topStep(array, compare, result, i, m) {\n    for (const n = result.length; i < m; i++) {\n        const element = array[i];\n        if (compare(element, result[n - 1]) < 0) {\n            result.pop();\n            const j = (0, arraysFind_1.findFirstIdxMonotonousOrArrLen)(result, e => compare(element, e) < 0);\n            result.splice(j, 0, element);\n        }\n    }\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nfunction coalesce(array) {\n    return array.filter((e) => !!e);\n}\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nfunction coalesceInPlace(array) {\n    let to = 0;\n    for (let i = 0; i < array.length; i++) {\n        if (!!array[i]) {\n            array[to] = array[i];\n            to += 1;\n        }\n    }\n    array.length = to;\n}\n/**\n * @deprecated Use `Array.copyWithin` instead\n */\nfunction move(array, from, to) {\n    array.splice(to, 0, array.splice(from, 1)[0]);\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\nfunction isFalsyOrEmpty(obj) {\n    return !Array.isArray(obj) || obj.length === 0;\n}\nfunction isNonEmptyArray(obj) {\n    return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nfunction distinct(array, keyFn = value => value) {\n    const seen = new Set();\n    return array.filter(element => {\n        const key = keyFn(element);\n        if (seen.has(key)) {\n            return false;\n        }\n        seen.add(key);\n        return true;\n    });\n}\nfunction uniqueFilter(keyFn) {\n    const seen = new Set();\n    return element => {\n        const key = keyFn(element);\n        if (seen.has(key)) {\n            return false;\n        }\n        seen.add(key);\n        return true;\n    };\n}\nfunction firstOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[0] : notFoundValue;\n}\nfunction lastOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[array.length - 1] : notFoundValue;\n}\nfunction commonPrefixLength(one, other, equals = (a, b) => a === b) {\n    let result = 0;\n    for (let i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n        result++;\n    }\n    return result;\n}\nfunction range(arg, to) {\n    let from = typeof to === 'number' ? arg : 0;\n    if (typeof to === 'number') {\n        from = arg;\n    }\n    else {\n        from = 0;\n        to = arg;\n    }\n    const result = [];\n    if (from <= to) {\n        for (let i = from; i < to; i++) {\n            result.push(i);\n        }\n    }\n    else {\n        for (let i = from; i > to; i--) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nfunction index(array, indexer, mapper) {\n    return array.reduce((r, t) => {\n        r[indexer(t)] = mapper ? mapper(t) : t;\n        return r;\n    }, Object.create(null));\n}\n/**\n * Inserts an element into an array. Returns a function which, when\n * called, will remove that element from the array.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nfunction insert(array, element) {\n    array.push(element);\n    return () => remove(array, element);\n}\n/**\n * Removes an element from an array if it can be found.\n *\n * @deprecated In almost all cases, use a `Set<T>` instead.\n */\nfunction remove(array, element) {\n    const index = array.indexOf(element);\n    if (index > -1) {\n        array.splice(index, 1);\n        return element;\n    }\n    return undefined;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nfunction arrayInsert(target, insertIndex, insertArr) {\n    const before = target.slice(0, insertIndex);\n    const after = target.slice(insertIndex);\n    return before.concat(insertArr, after);\n}\n/**\n * Uses Fisher-Yates shuffle to shuffle the given array\n */\nfunction shuffle(array, _seed) {\n    let rand;\n    if (typeof _seed === 'number') {\n        let seed = _seed;\n        // Seeded random number generator in JS. Modified from:\n        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\n        rand = () => {\n            const x = Math.sin(seed++) * 179426549; // throw away most significant digits and reduce any potential bias\n            return x - Math.floor(x);\n        };\n    }\n    else {\n        rand = Math.random;\n    }\n    for (let i = array.length - 1; i > 0; i -= 1) {\n        const j = Math.floor(rand() * (i + 1));\n        const temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\nfunction pushToStart(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.unshift(value);\n    }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\nfunction pushToEnd(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.push(value);\n    }\n}\nfunction pushMany(arr, items) {\n    for (const item of items) {\n        arr.push(item);\n    }\n}\nfunction mapArrayOrNot(items, fn) {\n    return Array.isArray(items) ?\n        items.map(fn) :\n        fn(items);\n}\nfunction asArray(x) {\n    return Array.isArray(x) ? x : [x];\n}\nfunction getRandomElement(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nfunction insertInto(array, start, newItems) {\n    const startIdx = getActualStartIndex(array, start);\n    const originalLength = array.length;\n    const newItemsLength = newItems.length;\n    array.length = originalLength + newItemsLength;\n    // Move the items after the start index, start from the end so that we don't overwrite any value.\n    for (let i = originalLength - 1; i >= startIdx; i--) {\n        array[i + newItemsLength] = array[i];\n    }\n    for (let i = 0; i < newItemsLength; i++) {\n        array[i + startIdx] = newItems[i];\n    }\n}\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nfunction splice(array, start, deleteCount, newItems) {\n    const index = getActualStartIndex(array, start);\n    let result = array.splice(index, deleteCount);\n    if (result === undefined) {\n        // see https://bugs.webkit.org/show_bug.cgi?id=261140\n        result = [];\n    }\n    insertInto(array, index, newItems);\n    return result;\n}\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex(array, start) {\n    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\nvar CompareResult;\n(function (CompareResult) {\n    function isLessThan(result) {\n        return result < 0;\n    }\n    CompareResult.isLessThan = isLessThan;\n    function isLessThanOrEqual(result) {\n        return result <= 0;\n    }\n    CompareResult.isLessThanOrEqual = isLessThanOrEqual;\n    function isGreaterThan(result) {\n        return result > 0;\n    }\n    CompareResult.isGreaterThan = isGreaterThan;\n    function isNeitherLessOrGreaterThan(result) {\n        return result === 0;\n    }\n    CompareResult.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;\n    CompareResult.greaterThan = 1;\n    CompareResult.lessThan = -1;\n    CompareResult.neitherLessOrGreaterThan = 0;\n})(CompareResult || (exports.CompareResult = CompareResult = {}));\nfunction compareBy(selector, comparator) {\n    return (a, b) => comparator(selector(a), selector(b));\n}\nfunction tieBreakComparators(...comparators) {\n    return (item1, item2) => {\n        for (const comparator of comparators) {\n            const result = comparator(item1, item2);\n            if (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n                return result;\n            }\n        }\n        return CompareResult.neitherLessOrGreaterThan;\n    };\n}\n/**\n * The natural order on numbers.\n*/\nconst numberComparator = (a, b) => a - b;\nexports.numberComparator = numberComparator;\nconst booleanComparator = (a, b) => (0, exports.numberComparator)(a ? 1 : 0, b ? 1 : 0);\nexports.booleanComparator = booleanComparator;\nfunction reverseOrder(comparator) {\n    return (a, b) => -comparator(a, b);\n}\nclass ArrayQueue {\n    /**\n     * Constructs a queue that is backed by the given array. Runtime is O(1).\n    */\n    constructor(items) {\n        this.items = items;\n        this.firstIdx = 0;\n        this.lastIdx = this.items.length - 1;\n    }\n    get length() {\n        return this.lastIdx - this.firstIdx + 1;\n    }\n    /**\n     * Consumes elements from the beginning of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n    */\n    takeWhile(predicate) {\n        // P(k) := k <= this.lastIdx && predicate(this.items[k])\n        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n        let startIdx = this.firstIdx;\n        while (startIdx < this.items.length && predicate(this.items[startIdx])) {\n            startIdx++;\n        }\n        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n        this.firstIdx = startIdx;\n        return result;\n    }\n    /**\n     * Consumes elements from the end of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned.\n     * The result has the same order as the underlying array!\n    */\n    takeFromEndWhile(predicate) {\n        // P(k) := this.firstIdx >= k && predicate(this.items[k])\n        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n        let endIdx = this.lastIdx;\n        while (endIdx >= 0 && predicate(this.items[endIdx])) {\n            endIdx--;\n        }\n        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n        this.lastIdx = endIdx;\n        return result;\n    }\n    peek() {\n        if (this.length === 0) {\n            return undefined;\n        }\n        return this.items[this.firstIdx];\n    }\n    peekLast() {\n        if (this.length === 0) {\n            return undefined;\n        }\n        return this.items[this.lastIdx];\n    }\n    dequeue() {\n        const result = this.items[this.firstIdx];\n        this.firstIdx++;\n        return result;\n    }\n    removeLast() {\n        const result = this.items[this.lastIdx];\n        this.lastIdx--;\n        return result;\n    }\n    takeCount(count) {\n        const result = this.items.slice(this.firstIdx, this.firstIdx + count);\n        this.firstIdx += count;\n        return result;\n    }\n}\nexports.ArrayQueue = ArrayQueue;\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nclass CallbackIterable {\n    static { this.empty = new CallbackIterable(_callback => { }); }\n    constructor(\n    /**\n     * Calls the callback for every item.\n     * Stops when the callback returns false.\n    */\n    iterate) {\n        this.iterate = iterate;\n    }\n    forEach(handler) {\n        this.iterate(item => { handler(item); return true; });\n    }\n    toArray() {\n        const result = [];\n        this.iterate(item => { result.push(item); return true; });\n        return result;\n    }\n    filter(predicate) {\n        return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n    }\n    map(mapFn) {\n        return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));\n    }\n    some(predicate) {\n        let result = false;\n        this.iterate(item => { result = predicate(item); return !result; });\n        return result;\n    }\n    findFirst(predicate) {\n        let result;\n        this.iterate(item => {\n            if (predicate(item)) {\n                result = item;\n                return false;\n            }\n            return true;\n        });\n        return result;\n    }\n    findLast(predicate) {\n        let result;\n        this.iterate(item => {\n            if (predicate(item)) {\n                result = item;\n            }\n            return true;\n        });\n        return result;\n    }\n    findLastMaxBy(comparator) {\n        let result;\n        let first = true;\n        this.iterate(item => {\n            if (first || CompareResult.isGreaterThan(comparator(item, result))) {\n                first = false;\n                result = item;\n            }\n            return true;\n        });\n        return result;\n    }\n}\nexports.CallbackIterable = CallbackIterable;\n/**\n * Represents a re-arrangement of items in an array.\n */\nclass Permutation {\n    constructor(_indexMap) {\n        this._indexMap = _indexMap;\n    }\n    /**\n     * Returns a permutation that sorts the given array according to the given compare function.\n     */\n    static createSortPermutation(arr, compareFn) {\n        const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n        return new Permutation(sortIndices);\n    }\n    /**\n     * Returns a new array with the elements of the given array re-arranged according to this permutation.\n     */\n    apply(arr) {\n        return arr.map((_, index) => arr[this._indexMap[index]]);\n    }\n    /**\n     * Returns a new permutation that undoes the re-arrangement of this permutation.\n    */\n    inverse() {\n        const inverseIndexMap = this._indexMap.slice();\n        for (let i = 0; i < this._indexMap.length; i++) {\n            inverseIndexMap[this._indexMap[i]] = i;\n        }\n        return new Permutation(inverseIndexMap);\n    }\n}\nexports.Permutation = Permutation;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MonotonousArray = void 0;\nexports.findLast = findLast;\nexports.findLastIdx = findLastIdx;\nexports.findLastMonotonous = findLastMonotonous;\nexports.findLastIdxMonotonous = findLastIdxMonotonous;\nexports.findFirstMonotonous = findFirstMonotonous;\nexports.findFirstIdxMonotonousOrArrLen = findFirstIdxMonotonousOrArrLen;\nexports.findFirstIdxMonotonous = findFirstIdxMonotonous;\nexports.findFirstMax = findFirstMax;\nexports.findLastMax = findLastMax;\nexports.findFirstMin = findFirstMin;\nexports.findMaxIdx = findMaxIdx;\nexports.mapFindFirst = mapFindFirst;\nfunction findLast(array, predicate) {\n    const idx = findLastIdx(array, predicate);\n    if (idx === -1) {\n        return undefined;\n    }\n    return array[idx];\n}\nfunction findLastIdx(array, predicate, fromIndex = array.length - 1) {\n    for (let i = fromIndex; i >= 0; i--) {\n        const element = array[i];\n        if (predicate(element)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nfunction findLastMonotonous(array, predicate) {\n    const idx = findLastIdxMonotonous(array, predicate);\n    return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nfunction findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            i = k + 1;\n        }\n        else {\n            j = k;\n        }\n    }\n    return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nfunction findFirstMonotonous(array, predicate) {\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n    return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nfunction findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            j = k;\n        }\n        else {\n            i = k + 1;\n        }\n    }\n    return i;\n}\nfunction findFirstIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate, startIdx, endIdxEx);\n    return idx === array.length ? -1 : idx;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nclass MonotonousArray {\n    static { this.assertInvariants = false; }\n    constructor(_array) {\n        this._array = _array;\n        this._findLastMonotonousLastIdx = 0;\n    }\n    /**\n     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n     */\n    findLastMonotonous(predicate) {\n        if (MonotonousArray.assertInvariants) {\n            if (this._prevFindLastPredicate) {\n                for (const item of this._array) {\n                    if (this._prevFindLastPredicate(item) && !predicate(item)) {\n                        throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n                    }\n                }\n            }\n            this._prevFindLastPredicate = predicate;\n        }\n        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n        this._findLastMonotonousLastIdx = idx + 1;\n        return idx === -1 ? undefined : this._array[idx];\n    }\n}\nexports.MonotonousArray = MonotonousArray;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nfunction findFirstMax(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) > 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nfunction findLastMax(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) >= 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nfunction findFirstMin(array, comparator) {\n    return findFirstMax(array, (a, b) => -comparator(a, b));\n}\nfunction findMaxIdx(array, comparator) {\n    if (array.length === 0) {\n        return -1;\n    }\n    let maxIdx = 0;\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, array[maxIdx]) > 0) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nfunction mapFindFirst(items, mapFn) {\n    for (const value of items) {\n        const mapped = mapFn(value);\n        if (mapped !== undefined) {\n            return mapped;\n        }\n    }\n    return undefined;\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetWithKey = void 0;\nexports.groupBy = groupBy;\nexports.diffSets = diffSets;\nexports.diffMaps = diffMaps;\nexports.intersection = intersection;\n/**\n * Groups the collection into a dictionary based on the provided\n * group function.\n */\nfunction groupBy(data, groupFn) {\n    const result = Object.create(null);\n    for (const element of data) {\n        const key = groupFn(element);\n        let target = result[key];\n        if (!target) {\n            target = result[key] = [];\n        }\n        target.push(element);\n    }\n    return result;\n}\nfunction diffSets(before, after) {\n    const removed = [];\n    const added = [];\n    for (const element of before) {\n        if (!after.has(element)) {\n            removed.push(element);\n        }\n    }\n    for (const element of after) {\n        if (!before.has(element)) {\n            added.push(element);\n        }\n    }\n    return { removed, added };\n}\nfunction diffMaps(before, after) {\n    const removed = [];\n    const added = [];\n    for (const [index, value] of before) {\n        if (!after.has(index)) {\n            removed.push(value);\n        }\n    }\n    for (const [index, value] of after) {\n        if (!before.has(index)) {\n            added.push(value);\n        }\n    }\n    return { removed, added };\n}\n/**\n * Computes the intersection of two sets.\n *\n * @param setA - The first set.\n * @param setB - The second iterable.\n * @returns A new set containing the elements that are in both `setA` and `setB`.\n */\nfunction intersection(setA, setB) {\n    const result = new Set();\n    for (const elem of setB) {\n        if (setA.has(elem)) {\n            result.add(elem);\n        }\n    }\n    return result;\n}\nclass SetWithKey {\n    static { _a = Symbol.toStringTag; }\n    constructor(values, toKey) {\n        this.toKey = toKey;\n        this._map = new Map();\n        this[_a] = 'SetWithKey';\n        for (const value of values) {\n            this.add(value);\n        }\n    }\n    get size() {\n        return this._map.size;\n    }\n    add(value) {\n        const key = this.toKey(value);\n        this._map.set(key, value);\n        return this;\n    }\n    delete(value) {\n        return this._map.delete(this.toKey(value));\n    }\n    has(value) {\n        return this._map.has(this.toKey(value));\n    }\n    *entries() {\n        for (const entry of this._map.values()) {\n            yield [entry, entry];\n        }\n    }\n    keys() {\n        return this.values();\n    }\n    *values() {\n        for (const entry of this._map.values()) {\n            yield entry;\n        }\n    }\n    clear() {\n        this._map.clear();\n    }\n    forEach(callbackfn, thisArg) {\n        this._map.forEach(entry => callbackfn.call(thisArg, entry, entry, this));\n    }\n    [Symbol.iterator]() {\n        return this.values();\n    }\n}\nexports.SetWithKey = SetWithKey;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BugIndicatingError = exports.ErrorNoTelemetry = exports.ExpectedError = exports.NotSupportedError = exports.NotImplementedError = exports.ReadonlyError = exports.CancellationError = exports.errorHandler = exports.ErrorHandler = void 0;\nexports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;\nexports.isSigPipeError = isSigPipeError;\nexports.onUnexpectedError = onUnexpectedError;\nexports.onUnexpectedExternalError = onUnexpectedExternalError;\nexports.transformErrorForSerialization = transformErrorForSerialization;\nexports.transformErrorFromSerialization = transformErrorFromSerialization;\nexports.isCancellationError = isCancellationError;\nexports.canceled = canceled;\nexports.illegalArgument = illegalArgument;\nexports.illegalState = illegalState;\nexports.getErrorMessage = getErrorMessage;\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nclass ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n                        throw new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n                    }\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    addListener(listener) {\n        this.listeners.push(listener);\n        return () => {\n            this._removeListener(listener);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    _removeListener(listener) {\n        this.listeners.splice(this.listeners.indexOf(listener), 1);\n    }\n    setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\n        this.unexpectedErrorHandler = newUnexpectedErrorHandler;\n    }\n    getUnexpectedErrorHandler() {\n        return this.unexpectedErrorHandler;\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nexports.ErrorHandler = ErrorHandler;\nexports.errorHandler = new ErrorHandler();\n/** @skipMangle */\nfunction setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\n    exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n/**\n * Returns if the error is a SIGPIPE error. SIGPIPE errors should generally be\n * logged at most once, to avoid a loop.\n *\n * @see https://github.com/microsoft/vscode-remote-release/issues/6481\n */\nfunction isSigPipeError(e) {\n    if (!e || typeof e !== 'object') {\n        return false;\n    }\n    const cast = e;\n    return cast.code === 'EPIPE' && cast.syscall?.toUpperCase() === 'WRITE';\n}\nfunction onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        exports.errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nfunction onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        exports.errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nfunction transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        const { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack,\n            noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n        };\n    }\n    // return as is\n    return error;\n}\nfunction transformErrorFromSerialization(data) {\n    let error;\n    if (data.noTelemetry) {\n        error = new ErrorNoTelemetry();\n    }\n    else {\n        error = new Error();\n        error.name = data.name;\n    }\n    error.message = data.message;\n    error.stack = data.stack;\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nfunction isCancellationError(error) {\n    if (error instanceof CancellationError) {\n        return true;\n    }\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nclass CancellationError extends Error {\n    constructor() {\n        super(canceledName);\n        this.name = this.message;\n    }\n}\nexports.CancellationError = CancellationError;\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nfunction canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nfunction illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nfunction illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nclass ReadonlyError extends TypeError {\n    constructor(name) {\n        super(name ? `${name} is read-only and cannot be changed` : 'Cannot change read-only property');\n    }\n}\nexports.ReadonlyError = ReadonlyError;\nfunction getErrorMessage(err) {\n    if (!err) {\n        return 'Error';\n    }\n    if (err.message) {\n        return err.message;\n    }\n    if (err.stack) {\n        return err.stack.split('\\n')[0];\n    }\n    return String(err);\n}\nclass NotImplementedError extends Error {\n    constructor(message) {\n        super('NotImplemented');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\nexports.NotImplementedError = NotImplementedError;\nclass NotSupportedError extends Error {\n    constructor(message) {\n        super('NotSupported');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\nexports.NotSupportedError = NotSupportedError;\nclass ExpectedError extends Error {\n    constructor() {\n        super(...arguments);\n        this.isExpected = true;\n    }\n}\nexports.ExpectedError = ExpectedError;\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nclass ErrorNoTelemetry extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'CodeExpectedError';\n    }\n    static fromError(err) {\n        if (err instanceof ErrorNoTelemetry) {\n            return err;\n        }\n        const result = new ErrorNoTelemetry();\n        result.message = err.message;\n        result.stack = err.stack;\n        return result;\n    }\n    static isErrorNoTelemetry(err) {\n        return err.name === 'CodeExpectedError';\n    }\n}\nexports.ErrorNoTelemetry = ErrorNoTelemetry;\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nclass BugIndicatingError extends Error {\n    constructor(message) {\n        super(message || 'An unexpected bug occurred.');\n        Object.setPrototypeOf(this, BugIndicatingError.prototype);\n        // Because we know for sure only buggy code throws this,\n        // we definitely want to break here and fix the bug.\n        // eslint-disable-next-line no-debugger\n        // debugger;\n    }\n}\nexports.BugIndicatingError = BugIndicatingError;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueWithChangeEvent = exports.Relay = exports.EventBufferer = exports.DynamicListEventMultiplexer = exports.EventMultiplexer = exports.MicrotaskEmitter = exports.DebounceEmitter = exports.PauseableEmitter = exports.AsyncEmitter = exports.createEventDeliveryQueue = exports.Emitter = exports.ListenerRefusalError = exports.ListenerLeakError = exports.EventProfiling = exports.Event = void 0;\nexports.setGlobalLeakWarningThreshold = setGlobalLeakWarningThreshold;\nconst errors_1 = require(\"vs/base/common/errors\");\nconst functional_1 = require(\"vs/base/common/functional\");\nconst lifecycle_1 = require(\"vs/base/common/lifecycle\");\nconst linkedList_1 = require(\"vs/base/common/linkedList\");\nconst stopwatch_1 = require(\"vs/base/common/stopwatch\");\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nvar Event;\n(function (Event) {\n    Event.None = () => lifecycle_1.Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd?.();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * Wraps an event in another event that performs some function on the event object before firing.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param each The function to perform on the event object.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => {\n            const disposable = (0, lifecycle_1.combinedDisposable)(...events.map(event => event(e => listener.call(thisArgs, e))));\n            return addAndReturnDisposable(disposable, disposables);\n        };\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener?.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    /**\n     * Adds the IDisposable to the store if it's set, and returns it. Useful to\n     * Event function implementation.\n     */\n    function addAndReturnDisposable(d, store) {\n        if (store instanceof Array) {\n            store.push(d);\n        }\n        else if (store) {\n            store.add(d);\n        }\n        return d;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire?.();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n     * event objects from different sources do not fire the same event object.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param equals The equality condition.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     *\n     * @example\n     * ```\n     * // Fire only one time when a single window is opened or focused\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n     * ```\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * Buffers an event until it has a listener attached.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n     * `setTimeout` when the first event listener is added.\n     * @param _buffer Internal: A source event array used for tests.\n     *\n     * @example\n     * ```\n     * // Start accumulating events, when the first listener is attached, flush\n     * // the event after a timeout such that multiple listeners attached before\n     * // the timeout would receive the event\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n     * ```\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        if (disposable) {\n            disposable.add(listener);\n        }\n        const flush = () => {\n            buffer?.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                    if (disposable) {\n                        disposable.add(listener);\n                    }\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    /**\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n     *\n     * @example\n     * ```\n     * // Normal\n     * const onEnterPressNormal = Event.filter(\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n     *   e.keyCode === KeyCode.Enter\n     * ).event;\n     *\n     * // Using chain\n     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n     *   .map(e => new StandardKeyboardEvent(e))\n     *   .filter(e => e.keyCode === KeyCode.Enter)\n     * );\n     * ```\n     */\n    function chain(event, sythensize) {\n        const fn = (listener, thisArgs, disposables) => {\n            const cs = sythensize(new ChainableSynthesis());\n            return event(function (value) {\n                const result = cs.evaluate(value);\n                if (result !== HaltChainable) {\n                    listener.call(thisArgs, result);\n                }\n            }, undefined, disposables);\n        };\n        return fn;\n    }\n    Event.chain = chain;\n    const HaltChainable = Symbol('HaltChainable');\n    class ChainableSynthesis {\n        constructor() {\n            this.steps = [];\n        }\n        map(fn) {\n            this.steps.push(fn);\n            return this;\n        }\n        forEach(fn) {\n            this.steps.push(v => {\n                fn(v);\n                return v;\n            });\n            return this;\n        }\n        filter(fn) {\n            this.steps.push(v => fn(v) ? v : HaltChainable);\n            return this;\n        }\n        reduce(merge, initial) {\n            let last = initial;\n            this.steps.push(v => {\n                last = merge(last, v);\n                return last;\n            });\n            return this;\n        }\n        latch(equals = (a, b) => a === b) {\n            let firstCall = true;\n            let cache;\n            this.steps.push(value => {\n                const shouldEmit = firstCall || !equals(value, cache);\n                firstCall = false;\n                cache = value;\n                return shouldEmit ? value : HaltChainable;\n            });\n            return this;\n        }\n        evaluate(value) {\n            for (const step of this.steps) {\n                value = step(value);\n                if (value === HaltChainable) {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    /**\n     * Creates an {@link Event} from a node event emitter.\n     */\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    /**\n     * Creates an {@link Event} from a DOM event emitter.\n     */\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    /**\n     * Creates a promise out of an event, using the {@link Event.once} helper.\n     */\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    /**\n     * Creates an event out of a promise that fires once when the promise is\n     * resolved with the result of the promise or `undefined`.\n     */\n    function fromPromise(promise) {\n        const result = new Emitter();\n        promise.then(res => {\n            result.fire(res);\n        }, () => {\n            result.fire(undefined);\n        }).finally(() => {\n            result.dispose();\n        });\n        return result.event;\n    }\n    Event.fromPromise = fromPromise;\n    /**\n     * A convenience function for forwarding an event to another emitter which\n     * improves readability.allows Event.forward(event, emitter) instead of `event(e => emitter.fire(e))`.\n     * @param from The event to forward.\n     * @param to The emitter to forward the event to.\n     * @example\n     * Event.forward(event, emitter);\n     * // equivalent to\n     * event(e => emitter.fire(e));\n     * // equivalent to\n     * event(emitter.fire, emitter);\n     */\n    function forward(from, to) {\n        return from(e => to.fire(e));\n    }\n    Event.forward = forward;\n    function runAndSubscribe(event, handler, initial) {\n        handler(initial);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n            // assert(_observable === this.obs);\n        }\n        handleChange(_observable, _change) {\n            // assert(_observable === this.obs);\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    /**\n     * Creates an event emitter that is fired when the observable changes.\n     * Each listeners subscribes to the emitter.\n     */\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    /**\n     * Each listener is attached to the observable directly.\n     */\n    function fromObservableLight(observable) {\n        return (listener, thisArgs, disposables) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener.call(thisArgs);\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                    // noop\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            const disposable = {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n            if (disposables instanceof lifecycle_1.DisposableStore) {\n                disposables.add(disposable);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (exports.Event = Event = {}));\nclass EventProfiling {\n    static { this.all = new Set(); }\n    static { this._idPool = 0; }\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new stopwatch_1.StopWatch();\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nexports.EventProfiling = EventProfiling;\nlet _globalLeakWarningThreshold = -1;\nfunction setGlobalLeakWarningThreshold(n) {\n    const oldValue = _globalLeakWarningThreshold;\n    _globalLeakWarningThreshold = n;\n    return {\n        dispose() {\n            _globalLeakWarningThreshold = oldValue;\n        }\n    };\n}\nclass LeakageMonitor {\n    static { this._idPool = 1; }\n    constructor(_errorHandler, threshold, name = (LeakageMonitor._idPool++).toString(16).padStart(3, '0')) {\n        this._errorHandler = _errorHandler;\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        this._stacks?.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            const [topStack, topCount] = this.getMostFrequentStack();\n            const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n            console.warn(message);\n            console.warn(topStack);\n            const error = new ListenerLeakError(message, topStack);\n            this._errorHandler(error);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n    getMostFrequentStack() {\n        if (!this._stacks) {\n            return undefined;\n        }\n        let topStack;\n        let topCount = 0;\n        for (const [stack, count] of this._stacks) {\n            if (!topStack || topCount < count) {\n                topStack = [stack, count];\n                topCount = count;\n            }\n        }\n        return topStack;\n    }\n}\nclass Stacktrace {\n    static create() {\n        const err = new Error();\n        return new Stacktrace(err.stack ?? '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\n// error that is logged when going over the configured listener threshold\nclass ListenerLeakError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerLeakError';\n        this.stack = stack;\n    }\n}\nexports.ListenerLeakError = ListenerLeakError;\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nclass ListenerRefusalError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerRefusalError';\n        this.stack = stack;\n    }\n}\nexports.ListenerRefusalError = ListenerRefusalError;\nlet id = 0;\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n        this.id = id++;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\nlet _listenerFinalizers;\nif (_enableListenerGCedWarning) {\n    const leaks = [];\n    setInterval(() => {\n        if (leaks.length === 0) {\n            return;\n        }\n        console.warn('[LEAKING LISTENERS] GC\\'ed these listeners that were NOT yet disposed:');\n        console.warn(leaks.join('\\n'));\n        leaks.length = 0;\n    }, 3000);\n    _listenerFinalizers = new FinalizationRegistry(heldValue => {\n        if (typeof heldValue === 'string') {\n            leaks.push(heldValue);\n        }\n    });\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nclass Emitter {\n    constructor(options) {\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = (_globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold)\n            ? new LeakageMonitor(options?.onListenerError ?? errors_1.onUnexpectedError, this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) :\n            undefined;\n        this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = this._options?.deliveryQueue;\n    }\n    dispose() {\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (this._deliveryQueue?.current === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = this._listeners;\n                    queueMicrotask(() => {\n                        forEachListener(listeners, l => l.stack?.print());\n                    });\n                }\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            this._options?.onDidRemoveLastListener?.();\n            this._leakageMon?.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        this._event ??= (callback, thisArgs, disposables) => {\n            if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n                const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n                console.warn(message);\n                const tuple = this._leakageMon.getMostFrequentStack() ?? ['UNKNOWN stack', -1];\n                const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n                const errorHandler = this._options?.onListenerError || errors_1.onUnexpectedError;\n                errorHandler(error);\n                return lifecycle_1.Disposable.None;\n            }\n            if (this._disposed) {\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\n                return lifecycle_1.Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = new UniqueContainer(callback);\n            let removeMonitor;\n            let stack;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                // check and record this emitter for potential leakage\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (_enableDisposeWithListenerWarning) {\n                contained.stack = stack ?? Stacktrace.create();\n            }\n            if (!this._listeners) {\n                this._options?.onWillAddFirstListener?.(this);\n                this._listeners = contained;\n                this._options?.onDidAddFirstListener?.(this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                this._deliveryQueue ??= new EventDeliveryQueuePrivate();\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = (0, lifecycle_1.toDisposable)(() => {\n                _listenerFinalizers?.unregister(result);\n                removeMonitor?.();\n                this._removeListener(contained);\n            });\n            if (disposables instanceof lifecycle_1.DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            if (_listenerFinalizers) {\n                const stack = new Error().stack.split('\\n').slice(2, 3).join('\\n').trim();\n                const match = /(file:|vscode-file:\\/\\/vscode-app)?(\\/[^:]*:\\d+:\\d+)/.exec(stack);\n                _listenerFinalizers.register(result, match?.[2] ?? stack, result);\n            }\n            return result;\n        };\n        return this._event;\n    }\n    _removeListener(listener) {\n        this._options?.onWillRemoveListener?.(this);\n        if (!this._listeners) {\n            return; // expected if a listener gets disposed\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            this._options?.onDidRemoveLastListener?.(this);\n            this._size = 0;\n            return;\n        }\n        // size > 1 which requires that listeners be a list:\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw new Error('Attempted to dispose unknown listener');\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        if (!listener) {\n            return;\n        }\n        const errorHandler = this._options?.onListenerError || errors_1.onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._deliveryQueue?.current) {\n            this._deliverQueue(this._deliveryQueue);\n            this._perfMon?.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n        }\n        this._perfMon?.start(this._size);\n        if (!this._listeners) {\n            // no-op\n        }\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        this._perfMon?.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nexports.Emitter = Emitter;\nconst createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nexports.createEventDeliveryQueue = createEventDeliveryQueue;\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        /**\n         * Index in current's listener list.\n         */\n        this.i = -1;\n        /**\n         * The last index in the listener's list to deliver.\n         */\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nclass AsyncEmitter extends Emitter {\n    async fireAsync(data, token, promiseJoin) {\n        if (!this._listeners) {\n            return;\n        }\n        if (!this._asyncDeliveryQueue) {\n            this._asyncDeliveryQueue = new linkedList_1.LinkedList();\n        }\n        forEachListener(this._listeners, listener => this._asyncDeliveryQueue.push([listener.value, data]));\n        while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n            const [listener, data] = this._asyncDeliveryQueue.shift();\n            const thenables = [];\n            const event = {\n                ...data,\n                token,\n                waitUntil: (p) => {\n                    if (Object.isFrozen(thenables)) {\n                        throw new Error('waitUntil can NOT be called asynchronous');\n                    }\n                    if (promiseJoin) {\n                        p = promiseJoin(p, listener);\n                    }\n                    thenables.push(p);\n                }\n            };\n            try {\n                listener(event);\n            }\n            catch (e) {\n                (0, errors_1.onUnexpectedError)(e);\n                continue;\n            }\n            // freeze thenables-collection to enforce sync-calls to\n            // wait until and then wait for all thenables to resolve\n            Object.freeze(thenables);\n            await Promise.allSettled(thenables).then(values => {\n                for (const value of values) {\n                    if (value.status === 'rejected') {\n                        (0, errors_1.onUnexpectedError)(value.reason);\n                    }\n                }\n            });\n        }\n    }\n}\nexports.AsyncEmitter = AsyncEmitter;\nclass PauseableEmitter extends Emitter {\n    get isPaused() {\n        return this._isPaused !== 0;\n    }\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new linkedList_1.LinkedList();\n        this._mergeFn = options?.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexports.PauseableEmitter = PauseableEmitter;\nclass DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        super(options);\n        this._delay = options.delay ?? 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\nexports.DebounceEmitter = DebounceEmitter;\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nclass MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options?.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\nexports.MicrotaskEmitter = MicrotaskEmitter;\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nclass EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return (0, lifecycle_1.toDisposable)((0, functional_1.createSingleCallFunction)(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        e.listener?.dispose();\n        e.listener = null;\n    }\n    dispose() {\n        this.emitter.dispose();\n        for (const e of this.events) {\n            e.listener?.dispose();\n        }\n        this.events = [];\n    }\n}\nexports.EventMultiplexer = EventMultiplexer;\nclass DynamicListEventMultiplexer {\n    constructor(items, onAddItem, onRemoveItem, getEvent) {\n        this._store = new lifecycle_1.DisposableStore();\n        const multiplexer = this._store.add(new EventMultiplexer());\n        const itemListeners = this._store.add(new lifecycle_1.DisposableMap());\n        function addItem(instance) {\n            itemListeners.set(instance, multiplexer.add(getEvent(instance)));\n        }\n        // Existing items\n        for (const instance of items) {\n            addItem(instance);\n        }\n        // Added items\n        this._store.add(onAddItem(instance => {\n            addItem(instance);\n        }));\n        // Removed items\n        this._store.add(onRemoveItem(instance => {\n            itemListeners.deleteAndDispose(instance);\n        }));\n        this.event = multiplexer.event;\n    }\n    dispose() {\n        this._store.dispose();\n    }\n}\nexports.DynamicListEventMultiplexer = DynamicListEventMultiplexer;\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nclass EventBufferer {\n    constructor() {\n        this.data = [];\n    }\n    wrapEvent(event, reduce, initial) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const data = this.data[this.data.length - 1];\n                // Non-reduce scenario\n                if (!reduce) {\n                    // Buffering case\n                    if (data) {\n                        data.buffers.push(() => listener.call(thisArgs, i));\n                    }\n                    else {\n                        // Not buffering case\n                        listener.call(thisArgs, i);\n                    }\n                    return;\n                }\n                // Reduce scenario\n                const reduceData = data;\n                // Not buffering case\n                if (!reduceData) {\n                    // TODO: Is there a way to cache this reduce call for all listeners?\n                    listener.call(thisArgs, reduce(initial, i));\n                    return;\n                }\n                // Buffering case\n                reduceData.items ??= [];\n                reduceData.items.push(i);\n                if (reduceData.buffers.length === 0) {\n                    // Include a single buffered function that will reduce all events when we're done buffering events\n                    data.buffers.push(() => {\n                        // cache the reduced result so that the value can be shared across all listeners\n                        reduceData.reducedResult ??= initial\n                            ? reduceData.items.reduce(reduce, initial)\n                            : reduceData.items.reduce(reduce);\n                        listener.call(thisArgs, reduceData.reducedResult);\n                    });\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const data = { buffers: new Array() };\n        this.data.push(data);\n        const r = fn();\n        this.data.pop();\n        data.buffers.forEach(flush => flush());\n        return r;\n    }\n}\nexports.EventBufferer = EventBufferer;\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nclass Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = lifecycle_1.Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\nexports.Relay = Relay;\nclass ValueWithChangeEvent {\n    static const(value) {\n        return new ConstValueWithChangeEvent(value);\n    }\n    constructor(_value) {\n        this._value = _value;\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        if (value !== this._value) {\n            this._value = value;\n            this._onDidChange.fire(undefined);\n        }\n    }\n}\nexports.ValueWithChangeEvent = ValueWithChangeEvent;\nclass ConstValueWithChangeEvent {\n    constructor(value) {\n        this.value = value;\n        this.onDidChange = Event.None;\n    }\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createSingleCallFunction = createSingleCallFunction;\n/**\n * Given a function, returns a function that is only calling that function once.\n */\nfunction createSingleCallFunction(fn, fnDidRunCallback) {\n    const _this = this;\n    let didCall = false;\n    let result;\n    return function () {\n        if (didCall) {\n            return result;\n        }\n        didCall = true;\n        if (fnDidRunCallback) {\n            try {\n                result = fn.apply(_this, arguments);\n            }\n            finally {\n                fnDidRunCallback();\n            }\n        }\n        else {\n            result = fn.apply(_this, arguments);\n        }\n        return result;\n    };\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Iterable = void 0;\nvar Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function wrap(iterableOrElement) {\n        if (is(iterableOrElement)) {\n            return iterableOrElement;\n        }\n        else {\n            return single(iterableOrElement);\n        }\n    }\n    Iterable.wrap = wrap;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function* reverse(array) {\n        for (let i = array.length - 1; i >= 0; i--) {\n            yield array[i];\n        }\n    }\n    Iterable.reverse = reverse;\n    function isEmpty(iterable) {\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\n    }\n    Iterable.isEmpty = isEmpty;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        let i = 0;\n        for (const element of iterable) {\n            if (predicate(element, i++)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function find(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    Iterable.find = find;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield fn(element, index++);\n        }\n    }\n    Iterable.map = map;\n    function* flatMap(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield* fn(element, index++);\n        }\n    }\n    Iterable.flatMap = flatMap;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    Iterable.concat = concat;\n    function reduce(iterable, reducer, initialValue) {\n        let value = initialValue;\n        for (const element of iterable) {\n            value = reducer(value, element);\n        }\n        return value;\n    }\n    Iterable.reduce = reduce;\n    /**\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n     */\n    function* slice(arr, from, to = arr.length) {\n        if (from < 0) {\n            from += arr.length;\n        }\n        if (to < 0) {\n            to += arr.length;\n        }\n        else if (to > arr.length) {\n            to = arr.length;\n        }\n        for (; from < to; from++) {\n            yield arr[from];\n        }\n    }\n    Iterable.slice = slice;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n    async function asyncToArray(iterable) {\n        const result = [];\n        for await (const item of iterable) {\n            result.push(item);\n        }\n        return Promise.resolve(result);\n    }\n    Iterable.asyncToArray = asyncToArray;\n})(Iterable || (exports.Iterable = Iterable = {}));\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DisposableMap = exports.ImmortalReference = exports.AsyncReferenceCollection = exports.ReferenceCollection = exports.SafeDisposable = exports.RefCountedDisposable = exports.MandatoryMutableDisposable = exports.MutableDisposable = exports.Disposable = exports.DisposableStore = exports.DisposableTracker = void 0;\nexports.setDisposableTracker = setDisposableTracker;\nexports.trackDisposable = trackDisposable;\nexports.markAsDisposed = markAsDisposed;\nexports.markAsSingleton = markAsSingleton;\nexports.isDisposable = isDisposable;\nexports.dispose = dispose;\nexports.disposeIfDisposable = disposeIfDisposable;\nexports.combinedDisposable = combinedDisposable;\nexports.toDisposable = toDisposable;\nexports.disposeOnReturn = disposeOnReturn;\nconst arrays_1 = require(\"vs/base/common/arrays\");\nconst collections_1 = require(\"vs/base/common/collections\");\nconst map_1 = require(\"./map\");\nconst functional_1 = require(\"vs/base/common/functional\");\nconst iterator_1 = require(\"vs/base/common/iterator\");\n// #region Disposable Tracking\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nclass DisposableTracker {\n    constructor() {\n        this.livingDisposables = new Map();\n    }\n    static { this.idx = 0; }\n    getDisposableData(d) {\n        let val = this.livingDisposables.get(d);\n        if (!val) {\n            val = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n            this.livingDisposables.set(d, val);\n        }\n        return val;\n    }\n    trackDisposable(d) {\n        const data = this.getDisposableData(d);\n        if (!data.source) {\n            data.source =\n                new Error().stack;\n        }\n    }\n    setParent(child, parent) {\n        const data = this.getDisposableData(child);\n        data.parent = parent;\n    }\n    markAsDisposed(x) {\n        this.livingDisposables.delete(x);\n    }\n    markAsSingleton(disposable) {\n        this.getDisposableData(disposable).isSingleton = true;\n    }\n    getRootParent(data, cache) {\n        const cacheValue = cache.get(data);\n        if (cacheValue) {\n            return cacheValue;\n        }\n        const result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n        cache.set(data, result);\n        return result;\n    }\n    getTrackedDisposables() {\n        const rootParentCache = new Map();\n        const leaking = [...this.livingDisposables.entries()]\n            .filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n            .flatMap(([k]) => k);\n        return leaking;\n    }\n    computeLeakingDisposables(maxReported = 10, preComputedLeaks) {\n        let uncoveredLeakingObjs;\n        if (preComputedLeaks) {\n            uncoveredLeakingObjs = preComputedLeaks;\n        }\n        else {\n            const rootParentCache = new Map();\n            const leakingObjects = [...this.livingDisposables.values()]\n                .filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n            if (leakingObjects.length === 0) {\n                return;\n            }\n            const leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n            // Remove all objects that are a child of other leaking objects. Assumes there are no cycles.\n            uncoveredLeakingObjs = leakingObjects.filter(l => {\n                return !(l.parent && leakingObjsSet.has(l.parent));\n            });\n            if (uncoveredLeakingObjs.length === 0) {\n                throw new Error('There are cyclic diposable chains!');\n            }\n        }\n        if (!uncoveredLeakingObjs) {\n            return undefined;\n        }\n        function getStackTracePath(leaking) {\n            function removePrefix(array, linesToRemove) {\n                while (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n                    array.shift();\n                }\n            }\n            const lines = leaking.source.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n            removePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n            return lines.reverse();\n        }\n        const stackTraceStarts = new map_1.SetMap();\n        for (const leaking of uncoveredLeakingObjs) {\n            const stackTracePath = getStackTracePath(leaking);\n            for (let i = 0; i <= stackTracePath.length; i++) {\n                stackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n            }\n        }\n        // Put earlier leaks first\n        uncoveredLeakingObjs.sort((0, arrays_1.compareBy)(l => l.idx, arrays_1.numberComparator));\n        let message = '';\n        let i = 0;\n        for (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n            i++;\n            const stackTracePath = getStackTracePath(leaking);\n            const stackTraceFormattedLines = [];\n            for (let i = 0; i < stackTracePath.length; i++) {\n                let line = stackTracePath[i];\n                const starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n                line = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n                const prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n                const continuations = (0, collections_1.groupBy)([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n                delete continuations[stackTracePath[i]];\n                for (const [cont, set] of Object.entries(continuations)) {\n                    stackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n                }\n                stackTraceFormattedLines.unshift(line);\n            }\n            message += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n        }\n        if (uncoveredLeakingObjs.length > maxReported) {\n            message += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n        }\n        return { leaks: uncoveredLeakingObjs, details: message };\n    }\n}\nexports.DisposableTracker = DisposableTracker;\nfunction setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    setDisposableTracker(new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        setParent(child, parent) {\n            if (child && child !== Disposable.None) {\n                try {\n                    child[__is_disposable_tracked__] = true;\n                }\n                catch {\n                    // noop\n                }\n            }\n        }\n        markAsDisposed(disposable) {\n            if (disposable && disposable !== Disposable.None) {\n                try {\n                    disposable[__is_disposable_tracked__] = true;\n                }\n                catch {\n                    // noop\n                }\n            }\n        }\n        markAsSingleton(disposable) { }\n    });\n}\nfunction trackDisposable(x) {\n    disposableTracker?.trackDisposable(x);\n    return x;\n}\nfunction markAsDisposed(disposable) {\n    disposableTracker?.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker?.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nfunction markAsSingleton(singleton) {\n    disposableTracker?.markAsSingleton(singleton);\n    return singleton;\n}\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nfunction isDisposable(thing) {\n    return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nfunction dispose(arg) {\n    if (iterator_1.Iterable.is(arg)) {\n        const errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new AggregateError(errors, 'Encountered errors while disposing of store');\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\nfunction disposeIfDisposable(disposables) {\n    for (const d of disposables) {\n        if (isDisposable(d)) {\n            d.dispose();\n        }\n    }\n    return [];\n}\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nfunction combinedDisposable(...disposables) {\n    const parent = toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nfunction toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: (0, functional_1.createSingleCallFunction)(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nclass DisposableStore {\n    static { this.DISABLE_DISPOSED_WARNING = false; }\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * @return `true` if this object has been disposed of.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        if (this._toDispose.size === 0) {\n            return;\n        }\n        try {\n            dispose(this._toDispose);\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    /**\n     * Add a new {@link IDisposable disposable} to the collection.\n     */\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n    /**\n     * Deletes a disposable from store and disposes of it. This will not throw or warn and proceed to dispose the\n     * disposable even when the disposable is not part in the store.\n     */\n    delete(o) {\n        if (!o) {\n            return;\n        }\n        if (o === this) {\n            throw new Error('Cannot dispose a disposable on itself!');\n        }\n        this._toDispose.delete(o);\n        o.dispose();\n    }\n    /**\n     * Deletes the value from the store, but does not dispose it.\n     */\n    deleteAndLeak(o) {\n        if (!o) {\n            return;\n        }\n        if (this._toDispose.has(o)) {\n            this._toDispose.delete(o);\n            setParentOfDisposable(o, null);\n        }\n    }\n}\nexports.DisposableStore = DisposableStore;\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nclass Disposable {\n    /**\n     * A disposable that does nothing when it is disposed of.\n     *\n     * TODO: This should not be a static property.\n     */\n    static { this.None = Object.freeze({ dispose() { } }); }\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    /**\n     * Adds `o` to the collection of disposables managed by this object.\n     */\n    _register(o) {\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(o);\n    }\n}\nexports.Disposable = Disposable;\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nclass MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        this._value?.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    /**\n     * Resets the stored value and disposed of the previously stored value.\n     */\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        this._isDisposed = true;\n        markAsDisposed(this);\n        this._value?.dispose();\n        this._value = undefined;\n    }\n    /**\n     * Clears the value, but does not dispose it.\n     * The old value is returned.\n    */\n    clearAndLeak() {\n        const oldValue = this._value;\n        this._value = undefined;\n        if (oldValue) {\n            setParentOfDisposable(oldValue, null);\n        }\n        return oldValue;\n    }\n}\nexports.MutableDisposable = MutableDisposable;\n/**\n * Manages the lifecycle of a disposable value that may be changed like {@link MutableDisposable}, but the value must\n * exist and cannot be undefined.\n */\nclass MandatoryMutableDisposable {\n    constructor(initialValue) {\n        this._disposable = new MutableDisposable();\n        this._isDisposed = false;\n        this._disposable.value = initialValue;\n    }\n    get value() {\n        return this._disposable.value;\n    }\n    set value(value) {\n        if (this._isDisposed || value === this._disposable.value) {\n            return;\n        }\n        this._disposable.value = value;\n    }\n    dispose() {\n        this._isDisposed = true;\n        this._disposable.dispose();\n    }\n}\nexports.MandatoryMutableDisposable = MandatoryMutableDisposable;\nclass RefCountedDisposable {\n    constructor(_disposable) {\n        this._disposable = _disposable;\n        this._counter = 1;\n    }\n    acquire() {\n        this._counter++;\n        return this;\n    }\n    release() {\n        if (--this._counter === 0) {\n            this._disposable.dispose();\n        }\n        return this;\n    }\n}\nexports.RefCountedDisposable = RefCountedDisposable;\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nclass SafeDisposable {\n    constructor() {\n        this.dispose = () => { };\n        this.unset = () => { };\n        this.isset = () => false;\n        trackDisposable(this);\n    }\n    set(fn) {\n        let callback = fn;\n        this.unset = () => callback = undefined;\n        this.isset = () => callback !== undefined;\n        this.dispose = () => {\n            if (callback) {\n                callback();\n                callback = undefined;\n                markAsDisposed(this);\n            }\n        };\n        return this;\n    }\n}\nexports.SafeDisposable = SafeDisposable;\nclass ReferenceCollection {\n    constructor() {\n        this.references = new Map();\n    }\n    acquire(key, ...args) {\n        let reference = this.references.get(key);\n        if (!reference) {\n            reference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n            this.references.set(key, reference);\n        }\n        const { object } = reference;\n        const dispose = (0, functional_1.createSingleCallFunction)(() => {\n            if (--reference.counter === 0) {\n                this.destroyReferencedObject(key, reference.object);\n                this.references.delete(key);\n            }\n        });\n        reference.counter++;\n        return { object, dispose };\n    }\n}\nexports.ReferenceCollection = ReferenceCollection;\n/**\n * Unwraps a reference collection of promised values. Makes sure\n * references are disposed whenever promises get rejected.\n */\nclass AsyncReferenceCollection {\n    constructor(referenceCollection) {\n        this.referenceCollection = referenceCollection;\n    }\n    async acquire(key, ...args) {\n        const ref = this.referenceCollection.acquire(key, ...args);\n        try {\n            const object = await ref.object;\n            return {\n                object,\n                dispose: () => ref.dispose()\n            };\n        }\n        catch (error) {\n            ref.dispose();\n            throw error;\n        }\n    }\n}\nexports.AsyncReferenceCollection = AsyncReferenceCollection;\nclass ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\nexports.ImmortalReference = ImmortalReference;\nfunction disposeOnReturn(fn) {\n    const store = new DisposableStore();\n    try {\n        fn(store);\n    }\n    finally {\n        store.dispose();\n    }\n}\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nclass DisposableMap {\n    constructor() {\n        this._store = new Map();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Disposes of all stored values and mark this object as disposed.\n     *\n     * Trying to use this object after it has been disposed of is an error.\n     */\n    dispose() {\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clearAndDisposeAll();\n    }\n    /**\n     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n     */\n    clearAndDisposeAll() {\n        if (!this._store.size) {\n            return;\n        }\n        try {\n            dispose(this._store.values());\n        }\n        finally {\n            this._store.clear();\n        }\n    }\n    has(key) {\n        return this._store.has(key);\n    }\n    get size() {\n        return this._store.size;\n    }\n    get(key) {\n        return this._store.get(key);\n    }\n    set(key, value, skipDisposeOnOverwrite = false) {\n        if (this._isDisposed) {\n            console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n        }\n        if (!skipDisposeOnOverwrite) {\n            this._store.get(key)?.dispose();\n        }\n        this._store.set(key, value);\n    }\n    /**\n     * Delete the value stored for `key` from this map and also dispose of it.\n     */\n    deleteAndDispose(key) {\n        this._store.get(key)?.dispose();\n        this._store.delete(key);\n    }\n    /**\n     * Delete the value stored for `key` from this map but return it. The caller is\n     * responsible for disposing of the value.\n     */\n    deleteAndLeak(key) {\n        const value = this._store.get(key);\n        this._store.delete(key);\n        return value;\n    }\n    keys() {\n        return this._store.keys();\n    }\n    values() {\n        return this._store.values();\n    }\n    [Symbol.iterator]() {\n        return this._store[Symbol.iterator]();\n    }\n}\nexports.DisposableMap = DisposableMap;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedList = void 0;\nclass Node {\n    static { this.Undefined = new Node(undefined); }\n    constructor(element) {\n        this.element = element;\n        this.next = Node.Undefined;\n        this.prev = Node.Undefined;\n    }\n}\nclass LinkedList {\n    constructor() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    get size() {\n        return this._size;\n    }\n    isEmpty() {\n        return this._first === Node.Undefined;\n    }\n    clear() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            const next = node.next;\n            node.prev = Node.Undefined;\n            node.next = Node.Undefined;\n            node = next;\n        }\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    unshift(element) {\n        return this._insert(element, false);\n    }\n    push(element) {\n        return this._insert(element, true);\n    }\n    _insert(element, atTheEnd) {\n        const newNode = new Node(element);\n        if (this._first === Node.Undefined) {\n            this._first = newNode;\n            this._last = newNode;\n        }\n        else if (atTheEnd) {\n            // push\n            const oldLast = this._last;\n            this._last = newNode;\n            newNode.prev = oldLast;\n            oldLast.next = newNode;\n        }\n        else {\n            // unshift\n            const oldFirst = this._first;\n            this._first = newNode;\n            newNode.next = oldFirst;\n            oldFirst.prev = newNode;\n        }\n        this._size += 1;\n        let didRemove = false;\n        return () => {\n            if (!didRemove) {\n                didRemove = true;\n                this._remove(newNode);\n            }\n        };\n    }\n    shift() {\n        if (this._first === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._first.element;\n            this._remove(this._first);\n            return res;\n        }\n    }\n    pop() {\n        if (this._last === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._last.element;\n            this._remove(this._last);\n            return res;\n        }\n    }\n    _remove(node) {\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n            // middle\n            const anchor = node.prev;\n            anchor.next = node.next;\n            node.next.prev = anchor;\n        }\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n            // only node\n            this._first = Node.Undefined;\n            this._last = Node.Undefined;\n        }\n        else if (node.next === Node.Undefined) {\n            // last\n            this._last = this._last.prev;\n            this._last.next = Node.Undefined;\n        }\n        else if (node.prev === Node.Undefined) {\n            // first\n            this._first = this._first.next;\n            this._first.prev = Node.Undefined;\n        }\n        // done\n        this._size -= 1;\n    }\n    *[Symbol.iterator]() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            yield node.element;\n            node = node.next;\n        }\n    }\n}\nexports.LinkedList = LinkedList;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SetMap = exports.BidirectionalMap = exports.CounterSet = exports.Touch = void 0;\nexports.getOrSet = getOrSet;\nexports.mapToString = mapToString;\nexports.setToString = setToString;\nexports.mapsStrictEqualIgnoreOrder = mapsStrictEqualIgnoreOrder;\nfunction getOrSet(map, key, value) {\n    let result = map.get(key);\n    if (result === undefined) {\n        result = value;\n        map.set(key, result);\n    }\n    return result;\n}\nfunction mapToString(map) {\n    const entries = [];\n    map.forEach((value, key) => {\n        entries.push(`${key} => ${value}`);\n    });\n    return `Map(${map.size}) {${entries.join(', ')}}`;\n}\nfunction setToString(set) {\n    const entries = [];\n    set.forEach(value => {\n        entries.push(value);\n    });\n    return `Set(${set.size}) {${entries.join(', ')}}`;\n}\nvar Touch;\n(function (Touch) {\n    Touch[Touch[\"None\"] = 0] = \"None\";\n    Touch[Touch[\"AsOld\"] = 1] = \"AsOld\";\n    Touch[Touch[\"AsNew\"] = 2] = \"AsNew\";\n})(Touch || (exports.Touch = Touch = {}));\nclass CounterSet {\n    constructor() {\n        this.map = new Map();\n    }\n    add(value) {\n        this.map.set(value, (this.map.get(value) || 0) + 1);\n        return this;\n    }\n    delete(value) {\n        let counter = this.map.get(value) || 0;\n        if (counter === 0) {\n            return false;\n        }\n        counter--;\n        if (counter === 0) {\n            this.map.delete(value);\n        }\n        else {\n            this.map.set(value, counter);\n        }\n        return true;\n    }\n    has(value) {\n        return this.map.has(value);\n    }\n}\nexports.CounterSet = CounterSet;\n/**\n * A map that allows access both by keys and values.\n * **NOTE**: values need to be unique.\n */\nclass BidirectionalMap {\n    constructor(entries) {\n        this._m1 = new Map();\n        this._m2 = new Map();\n        if (entries) {\n            for (const [key, value] of entries) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this._m1.clear();\n        this._m2.clear();\n    }\n    set(key, value) {\n        this._m1.set(key, value);\n        this._m2.set(value, key);\n    }\n    get(key) {\n        return this._m1.get(key);\n    }\n    getKey(value) {\n        return this._m2.get(value);\n    }\n    delete(key) {\n        const value = this._m1.get(key);\n        if (value === undefined) {\n            return false;\n        }\n        this._m1.delete(key);\n        this._m2.delete(value);\n        return true;\n    }\n    forEach(callbackfn, thisArg) {\n        this._m1.forEach((value, key) => {\n            callbackfn.call(thisArg, value, key, this);\n        });\n    }\n    keys() {\n        return this._m1.keys();\n    }\n    values() {\n        return this._m1.values();\n    }\n}\nexports.BidirectionalMap = BidirectionalMap;\nclass SetMap {\n    constructor() {\n        this.map = new Map();\n    }\n    add(key, value) {\n        let values = this.map.get(key);\n        if (!values) {\n            values = new Set();\n            this.map.set(key, values);\n        }\n        values.add(value);\n    }\n    delete(key, value) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.delete(value);\n        if (values.size === 0) {\n            this.map.delete(key);\n        }\n    }\n    forEach(key, fn) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.forEach(fn);\n    }\n    get(key) {\n        const values = this.map.get(key);\n        if (!values) {\n            return new Set();\n        }\n        return values;\n    }\n}\nexports.SetMap = SetMap;\nfunction mapsStrictEqualIgnoreOrder(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, value] of a) {\n        if (!b.has(key) || b.get(key) !== value) {\n            return false;\n        }\n    }\n    for (const [key] of b) {\n        if (!a.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StopWatch = void 0;\nconst hasPerformanceNow = (globalThis.performance && typeof globalThis.performance.now === 'function');\nclass StopWatch {\n    static create(highResolution) {\n        return new StopWatch(highResolution);\n    }\n    constructor(highResolution) {\n        this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);\n        this._startTime = this._now();\n        this._stopTime = -1;\n    }\n    stop() {\n        this._stopTime = this._now();\n    }\n    reset() {\n        this._startTime = this._now();\n        this._stopTime = -1;\n    }\n    elapsed() {\n        if (this._stopTime !== -1) {\n            return this._stopTime - this._startTime;\n        }\n        return this._now() - this._startTime;\n    }\n}\nexports.StopWatch = StopWatch;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport type { Terminal, IDisposable, ITerminalAddon, IDecoration } from '@xterm/xterm';\nimport type { SearchAddon as ISearchApi } from '@xterm/addon-search';\nimport { Emitter } from 'vs/base/common/event';\nimport { combinedDisposable, Disposable, dispose, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\n\nexport interface ISearchOptions {\n  regex?: boolean;\n  wholeWord?: boolean;\n  caseSensitive?: boolean;\n  incremental?: boolean;\n  decorations?: ISearchDecorationOptions;\n  noScroll?: boolean;\n}\n\ninterface ISearchDecorationOptions {\n  matchBackground?: string;\n  matchBorder?: string;\n  matchOverviewRuler: string;\n  activeMatchBackground?: string;\n  activeMatchBorder?: string;\n  activeMatchColorOverviewRuler: string;\n}\n\nexport interface ISearchPosition {\n  startCol: number;\n  startRow: number;\n}\n\nexport interface ISearchAddonOptions {\n  highlightLimit: number;\n}\n\nexport interface ISearchResult {\n  term: string;\n  col: number;\n  row: number;\n  size: number;\n}\n\ntype LineCacheEntry = [\n  /**\n   * The string representation of a line (as opposed to the buffer cell representation).\n   */\n  lineAsString: string,\n  /**\n   * The offsets where each line starts when the entry describes a wrapped line.\n   */\n  lineOffsets: number[]\n];\n\ninterface IHighlight extends IDisposable {\n  decoration: IDecoration;\n  match: ISearchResult;\n}\n\nconst NON_WORD_CHARACTERS = ' ~!@#$%^&*()+`-=[]{}|\\\\;:\"\\',./<>?';\nconst LINES_CACHE_TIME_TO_LIVE = 15 * 1000; // 15 secs\nconst DEFAULT_HIGHLIGHT_LIMIT = 1000;\n\nexport class SearchAddon extends Disposable implements ITerminalAddon , ISearchApi {\n  private _terminal: Terminal | undefined;\n  private _cachedSearchTerm: string | undefined;\n  private _highlightedLines: Set<number> = new Set();\n  private _highlightDecorations: IHighlight[] = [];\n  private _selectedDecoration: MutableDisposable<IHighlight> = this._register(new MutableDisposable());\n  private _highlightLimit: number;\n  private _lastSearchOptions: ISearchOptions | undefined;\n  private _highlightTimeout: number | undefined;\n  /**\n   * translateBufferLineToStringWithWrap is a fairly expensive call.\n   * We memoize the calls into an array that has a time based ttl.\n   * _linesCache is also invalidated when the terminal cursor moves.\n   */\n  private _linesCache: LineCacheEntry[] | undefined;\n  private _linesCacheTimeoutId = 0;\n  private _linesCacheDisposables = new MutableDisposable();\n\n  private readonly _onDidChangeResults = this._register(new Emitter<{ resultIndex: number, resultCount: number }>());\n  public readonly onDidChangeResults = this._onDidChangeResults.event;\n\n  constructor(options?: Partial<ISearchAddonOptions>) {\n    super();\n\n    this._highlightLimit = options?.highlightLimit ?? DEFAULT_HIGHLIGHT_LIMIT;\n  }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n    this._register(this._terminal.onWriteParsed(() => this._updateMatches()));\n    this._register(this._terminal.onResize(() => this._updateMatches()));\n    this._register(toDisposable(() => this.clearDecorations()));\n  }\n\n  private _updateMatches(): void {\n    if (this._highlightTimeout) {\n      window.clearTimeout(this._highlightTimeout);\n    }\n    if (this._cachedSearchTerm && this._lastSearchOptions?.decorations) {\n      this._highlightTimeout = setTimeout(() => {\n        const term = this._cachedSearchTerm;\n        this._cachedSearchTerm = undefined;\n        this.findPrevious(term!, { ...this._lastSearchOptions, incremental: true, noScroll: true });\n      }, 200);\n    }\n  }\n\n  public clearDecorations(retainCachedSearchTerm?: boolean): void {\n    this._selectedDecoration.clear();\n    dispose(this._highlightDecorations);\n    this._highlightDecorations = [];\n    this._highlightedLines.clear();\n    if (!retainCachedSearchTerm) {\n      this._cachedSearchTerm = undefined;\n    }\n  }\n\n  public clearActiveDecoration(): void {\n    this._selectedDecoration.clear();\n  }\n\n  /**\n   * Find the next instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @returns Whether a result was found.\n   */\n  public findNext(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    const didOptionsChanged = this._lastSearchOptions ? this._didOptionsChange(this._lastSearchOptions, searchOptions) : true;\n    this._lastSearchOptions = searchOptions;\n    if (searchOptions?.decorations) {\n      if (this._cachedSearchTerm === undefined || term !== this._cachedSearchTerm || didOptionsChanged) {\n        this._highlightAllMatches(term, searchOptions);\n      }\n    }\n\n    const found = this._findNextAndSelect(term, searchOptions);\n    this._fireResults(searchOptions);\n    this._cachedSearchTerm = term;\n\n    return found;\n  }\n\n  private _highlightAllMatches(term: string, searchOptions: ISearchOptions): void {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    if (!term || term.length === 0) {\n      this.clearDecorations();\n      return;\n    }\n    searchOptions = searchOptions || {};\n\n    // new search, clear out the old decorations\n    this.clearDecorations(true);\n\n    const searchResultsWithHighlight: ISearchResult[] = [];\n    let prevResult: ISearchResult | undefined = undefined;\n    let result = this._find(term, 0, 0, searchOptions);\n    while (result && (prevResult?.row !== result.row || prevResult?.col !== result.col)) {\n      if (searchResultsWithHighlight.length >= this._highlightLimit) {\n        break;\n      }\n      prevResult = result;\n      searchResultsWithHighlight.push(prevResult);\n      result = this._find(\n        term,\n        prevResult.col + prevResult.term.length >= this._terminal.cols ? prevResult.row + 1 : prevResult.row,\n        prevResult.col + prevResult.term.length >= this._terminal.cols ? 0 : prevResult.col + 1,\n        searchOptions\n      );\n    }\n    for (const match of searchResultsWithHighlight) {\n      const decoration = this._createResultDecoration(match, searchOptions.decorations!);\n      if (decoration) {\n        this._highlightedLines.add(decoration.marker.line);\n        this._highlightDecorations.push({ decoration, match, dispose() { decoration.dispose(); } });\n      }\n    }\n  }\n\n  private _find(term: string, startRow: number, startCol: number, searchOptions?: ISearchOptions): ISearchResult | undefined {\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return undefined;\n    }\n    if (startCol > this._terminal.cols) {\n      throw new Error(`Invalid col: ${startCol} to search in terminal of ${this._terminal.cols} cols`);\n    }\n\n    let result: ISearchResult | undefined = undefined;\n\n    this._initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    result = this._findInLine(term, searchPosition, searchOptions);\n    // Search from startRow + 1 to end\n    if (!result) {\n\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        // If the current line is wrapped line, increase index of column to ignore the previous scan\n        // Otherwise, reset beginning column index to zero with set new unwrapped line index\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  private _findNextAndSelect(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return false;\n    }\n\n    const prevSelectedPos = this._terminal.getSelectionPosition();\n    this._terminal.clearSelection();\n\n    let startCol = 0;\n    let startRow = 0;\n    if (prevSelectedPos) {\n      if (this._cachedSearchTerm === term) {\n        startCol = prevSelectedPos.end.x;\n        startRow = prevSelectedPos.end.y;\n      } else {\n        startCol = prevSelectedPos.start.x;\n        startRow = prevSelectedPos.start.y;\n      }\n    }\n\n    this._initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    let result = this._findInLine(term, searchPosition, searchOptions);\n    // Search from startRow + 1 to end\n    if (!result) {\n\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        // If the current line is wrapped line, increase index of column to ignore the previous scan\n        // Otherwise, reset beginning column index to zero with set new unwrapped line index\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the bottom and didn't search from the very top wrap back up\n    if (!result && startRow !== 0) {\n      for (let y = 0; y < startRow; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // If there is only one result, wrap back and return selection if it exists.\n    if (!result && prevSelectedPos) {\n      searchPosition.startRow = prevSelectedPos.start.y;\n      searchPosition.startCol = 0;\n      result = this._findInLine(term, searchPosition, searchOptions);\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result, searchOptions?.decorations, searchOptions?.noScroll);\n  }\n  /**\n   * Find the previous instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @returns Whether a result was found.\n   */\n  public findPrevious(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    const didOptionsChanged = this._lastSearchOptions ? this._didOptionsChange(this._lastSearchOptions, searchOptions) : true;\n    this._lastSearchOptions = searchOptions;\n    if (searchOptions?.decorations) {\n      if (this._cachedSearchTerm === undefined || term !== this._cachedSearchTerm || didOptionsChanged) {\n        this._highlightAllMatches(term, searchOptions);\n      }\n    }\n\n    const found = this._findPreviousAndSelect(term, searchOptions);\n    this._fireResults(searchOptions);\n    this._cachedSearchTerm = term;\n\n    return found;\n  }\n\n  private _didOptionsChange(lastSearchOptions: ISearchOptions, searchOptions?: ISearchOptions): boolean {\n    if (!searchOptions) {\n      return false;\n    }\n    if (lastSearchOptions.caseSensitive !== searchOptions.caseSensitive) {\n      return true;\n    }\n    if (lastSearchOptions.regex !== searchOptions.regex) {\n      return true;\n    }\n    if (lastSearchOptions.wholeWord !== searchOptions.wholeWord) {\n      return true;\n    }\n    return false;\n  }\n\n  private _fireResults(searchOptions?: ISearchOptions): void {\n    if (searchOptions?.decorations) {\n      let resultIndex = -1;\n      if (this._selectedDecoration.value) {\n        const selectedMatch = this._selectedDecoration.value.match;\n        for (let i = 0; i < this._highlightDecorations.length; i++) {\n          const match = this._highlightDecorations[i].match;\n          if (match.row === selectedMatch.row && match.col === selectedMatch.col && match.size === selectedMatch.size) {\n            resultIndex = i;\n            break;\n          }\n        }\n      }\n      this._onDidChangeResults.fire({ resultIndex, resultCount: this._highlightDecorations.length });\n    }\n  }\n\n  private _findPreviousAndSelect(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return false;\n    }\n\n    const prevSelectedPos = this._terminal.getSelectionPosition();\n    this._terminal.clearSelection();\n\n    let startRow = this._terminal.buffer.active.baseY + this._terminal.rows - 1;\n    let startCol = this._terminal.cols;\n    const isReverseSearch = true;\n\n    this._initLinesCache();\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    let result: ISearchResult | undefined;\n    if (prevSelectedPos) {\n      searchPosition.startRow = startRow = prevSelectedPos.start.y;\n      searchPosition.startCol = startCol = prevSelectedPos.start.x;\n      if (this._cachedSearchTerm !== term) {\n        // Try to expand selection to right first.\n        result = this._findInLine(term, searchPosition, searchOptions, false);\n        if (!result) {\n          // If selection was not able to be expanded to the right, then try reverse search\n          searchPosition.startRow = startRow = prevSelectedPos.end.y;\n          searchPosition.startCol = startCol = prevSelectedPos.end.x;\n        }\n      }\n    }\n\n    if (!result) {\n      result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n    }\n\n    // Search from startRow - 1 to top\n    if (!result) {\n      searchPosition.startCol = Math.max(searchPosition.startCol, this._terminal.cols);\n      for (let y = startRow - 1; y >= 0; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the top and didn't search from the very bottom wrap back down\n    if (!result && startRow !== (this._terminal.buffer.active.baseY + this._terminal.rows - 1)) {\n      for (let y = (this._terminal.buffer.active.baseY + this._terminal.rows - 1); y >= startRow; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result, searchOptions?.decorations, searchOptions?.noScroll);\n  }\n\n  /**\n   * Sets up a line cache with a ttl\n   */\n  private _initLinesCache(): void {\n    const terminal = this._terminal!;\n    if (!this._linesCache) {\n      this._linesCache = new Array(terminal.buffer.active.length);\n      this._linesCacheDisposables.value = combinedDisposable(\n        terminal.onLineFeed(() => this._destroyLinesCache()),\n        terminal.onCursorMove(() => this._destroyLinesCache()),\n        terminal.onResize(() => this._destroyLinesCache())\n      );\n    }\n\n    window.clearTimeout(this._linesCacheTimeoutId);\n    this._linesCacheTimeoutId = window.setTimeout(() => this._destroyLinesCache(), LINES_CACHE_TIME_TO_LIVE);\n  }\n\n  private _destroyLinesCache(): void {\n    this._linesCache = undefined;\n    this._linesCacheDisposables.clear();\n    if (this._linesCacheTimeoutId) {\n      window.clearTimeout(this._linesCacheTimeoutId);\n      this._linesCacheTimeoutId = 0;\n    }\n  }\n\n  /**\n   * A found substring is a whole word if it doesn't have an alphanumeric character directly\n   * adjacent to it.\n   * @param searchIndex starting indext of the potential whole word substring\n   * @param line entire string in which the potential whole word was found\n   * @param term the substring that starts at searchIndex\n   */\n  private _isWholeWord(searchIndex: number, line: string, term: string): boolean {\n    return ((searchIndex === 0) || (NON_WORD_CHARACTERS.includes(line[searchIndex - 1]))) &&\n      (((searchIndex + term.length) === line.length) || (NON_WORD_CHARACTERS.includes(line[searchIndex + term.length])));\n  }\n\n  /**\n   * Searches a line for a search term. Takes the provided terminal line and searches the text line,\n   * which may contain subsequent terminal lines if the text is wrapped. If the provided line number\n   * is part of a wrapped text line that started on an earlier line then it is skipped since it will\n   * be properly searched when the terminal line that the text starts on is searched.\n   * @param term The search term.\n   * @param searchPosition The position to start the search.\n   * @param searchOptions Search options.\n   * @param isReverseSearch Whether the search should start from the right side of the terminal and\n   * search to the left.\n   * @returns The search result if it was found.\n   */\n  protected _findInLine(term: string, searchPosition: ISearchPosition, searchOptions: ISearchOptions = {}, isReverseSearch: boolean = false): ISearchResult | undefined {\n    const terminal = this._terminal!;\n    const row = searchPosition.startRow;\n    const col = searchPosition.startCol;\n\n    // Ignore wrapped lines, only consider on unwrapped line (first row of command string).\n    const firstLine = terminal.buffer.active.getLine(row);\n    if (firstLine?.isWrapped) {\n      if (isReverseSearch) {\n        searchPosition.startCol += terminal.cols;\n        return;\n      }\n\n      // This will iterate until we find the line start.\n      // When we find it, we will search using the calculated start column.\n      searchPosition.startRow--;\n      searchPosition.startCol += terminal.cols;\n      return this._findInLine(term, searchPosition, searchOptions);\n    }\n    let cache = this._linesCache?.[row];\n    if (!cache) {\n      cache = this._translateBufferLineToStringWithWrap(row, true);\n      if (this._linesCache) {\n        this._linesCache[row] = cache;\n      }\n    }\n    const [stringLine, offsets] = cache;\n\n    const offset = this._bufferColsToStringOffset(row, col);\n    const searchTerm = searchOptions.caseSensitive ? term : term.toLowerCase();\n    const searchStringLine = searchOptions.caseSensitive ? stringLine : stringLine.toLowerCase();\n\n    let resultIndex = -1;\n    if (searchOptions.regex) {\n      const searchRegex = RegExp(searchTerm, 'g');\n      let foundTerm: RegExpExecArray | null;\n      if (isReverseSearch) {\n        // This loop will get the resultIndex of the _last_ regex match in the range 0..offset\n        while (foundTerm = searchRegex.exec(searchStringLine.slice(0, offset))) {\n          resultIndex = searchRegex.lastIndex - foundTerm[0].length;\n          term = foundTerm[0];\n          searchRegex.lastIndex -= (term.length - 1);\n        }\n      } else {\n        foundTerm = searchRegex.exec(searchStringLine.slice(offset));\n        if (foundTerm && foundTerm[0].length > 0) {\n          resultIndex = offset + (searchRegex.lastIndex - foundTerm[0].length);\n          term = foundTerm[0];\n        }\n      }\n    } else {\n      if (isReverseSearch) {\n        if (offset - searchTerm.length >= 0) {\n          resultIndex = searchStringLine.lastIndexOf(searchTerm, offset - searchTerm.length);\n        }\n      } else {\n        resultIndex = searchStringLine.indexOf(searchTerm, offset);\n      }\n    }\n\n    if (resultIndex >= 0) {\n      if (searchOptions.wholeWord && !this._isWholeWord(resultIndex, searchStringLine, term)) {\n        return;\n      }\n\n      // Adjust the row number and search index if needed since a \"line\" of text can span multiple\n      // rows\n      let startRowOffset = 0;\n      while (startRowOffset < offsets.length - 1 && resultIndex >= offsets[startRowOffset + 1]) {\n        startRowOffset++;\n      }\n      let endRowOffset = startRowOffset;\n      while (endRowOffset < offsets.length - 1 && resultIndex + term.length >= offsets[endRowOffset + 1]) {\n        endRowOffset++;\n      }\n      const startColOffset = resultIndex - offsets[startRowOffset];\n      const endColOffset = resultIndex + term.length - offsets[endRowOffset];\n      const startColIndex = this._stringLengthToBufferSize(row + startRowOffset, startColOffset);\n      const endColIndex = this._stringLengthToBufferSize(row + endRowOffset, endColOffset);\n      const size = endColIndex - startColIndex + terminal.cols * (endRowOffset - startRowOffset);\n\n      return {\n        term,\n        col: startColIndex,\n        row: row + startRowOffset,\n        size\n      };\n    }\n  }\n\n  private _stringLengthToBufferSize(row: number, offset: number): number {\n    const line = this._terminal!.buffer.active.getLine(row);\n    if (!line) {\n      return 0;\n    }\n    for (let i = 0; i < offset; i++) {\n      const cell = line.getCell(i);\n      if (!cell) {\n        break;\n      }\n      // Adjust the searchIndex to normalize emoji into single chars\n      const char = cell.getChars();\n      if (char.length > 1) {\n        offset -= char.length - 1;\n      }\n      // Adjust the searchIndex for empty characters following wide unicode\n      // chars (eg. CJK)\n      const nextCell = line.getCell(i + 1);\n      if (nextCell && nextCell.getWidth() === 0) {\n        offset++;\n      }\n    }\n    return offset;\n  }\n\n  private _bufferColsToStringOffset(startRow: number, cols: number): number {\n    const terminal = this._terminal!;\n    let lineIndex = startRow;\n    let offset = 0;\n    let line = terminal.buffer.active.getLine(lineIndex);\n    while (cols > 0 && line) {\n      for (let i = 0; i < cols && i < terminal.cols; i++) {\n        const cell = line.getCell(i);\n        if (!cell) {\n          break;\n        }\n        if (cell.getWidth()) {\n          // Treat null characters as whitespace to align with the translateToString API\n          offset += cell.getCode() === 0 ? 1 : cell.getChars().length;\n        }\n      }\n      lineIndex++;\n      line = terminal.buffer.active.getLine(lineIndex);\n      if (line && !line.isWrapped) {\n        break;\n      }\n      cols -= terminal.cols;\n    }\n    return offset;\n  }\n\n  /**\n   * Translates a buffer line to a string, including subsequent lines if they are wraps.\n   * Wide characters will count as two columns in the resulting string. This\n   * function is useful for getting the actual text underneath the raw selection\n   * position.\n   * @param lineIndex The index of the line being translated.\n   * @param trimRight Whether to trim whitespace to the right.\n   */\n  private _translateBufferLineToStringWithWrap(lineIndex: number, trimRight: boolean): LineCacheEntry {\n    const terminal = this._terminal!;\n    const strings = [];\n    const lineOffsets = [0];\n    let line = terminal.buffer.active.getLine(lineIndex);\n    while (line) {\n      const nextLine = terminal.buffer.active.getLine(lineIndex + 1);\n      const lineWrapsToNext = nextLine ? nextLine.isWrapped : false;\n      let string = line.translateToString(!lineWrapsToNext && trimRight);\n      if (lineWrapsToNext && nextLine) {\n        const lastCell = line.getCell(line.length - 1);\n        const lastCellIsNull = lastCell && lastCell.getCode() === 0 && lastCell.getWidth() === 1;\n        // a wide character wrapped to the next line\n        if (lastCellIsNull && nextLine.getCell(0)?.getWidth() === 2) {\n          string = string.slice(0, -1);\n        }\n      }\n      strings.push(string);\n      if (lineWrapsToNext) {\n        lineOffsets.push(lineOffsets[lineOffsets.length - 1] + string.length);\n      } else {\n        break;\n      }\n      lineIndex++;\n      line = nextLine;\n    }\n    return [strings.join(''), lineOffsets];\n  }\n\n  /**\n   * Selects and scrolls to a result.\n   * @param result The result to select.\n   * @returns Whether a result was selected.\n   */\n  private _selectResult(result: ISearchResult | undefined, options?: ISearchDecorationOptions, noScroll?: boolean): boolean {\n    const terminal = this._terminal!;\n    this._selectedDecoration.clear();\n    if (!result) {\n      terminal.clearSelection();\n      return false;\n    }\n    terminal.select(result.col, result.row, result.size);\n    if (options) {\n      const marker = terminal.registerMarker(-terminal.buffer.active.baseY - terminal.buffer.active.cursorY + result.row);\n      if (marker) {\n        const decoration = terminal.registerDecoration({\n          marker,\n          x: result.col,\n          width: result.size,\n          backgroundColor: options.activeMatchBackground,\n          layer: 'top',\n          overviewRulerOptions: {\n            color: options.activeMatchColorOverviewRuler\n          }\n        });\n        if (decoration) {\n          const disposables: IDisposable[] = [];\n          disposables.push(marker);\n          disposables.push(decoration.onRender((e) => this._applyStyles(e, options.activeMatchBorder, true)));\n          disposables.push(decoration.onDispose(() => dispose(disposables)));\n          this._selectedDecoration.value = { decoration, match: result, dispose() { decoration.dispose(); } };\n        }\n      }\n    }\n\n    if (!noScroll) {\n      // If it is not in the viewport then we scroll else it just gets selected\n      if (result.row >= (terminal.buffer.active.viewportY + terminal.rows) || result.row < terminal.buffer.active.viewportY) {\n        let scroll = result.row - terminal.buffer.active.viewportY;\n        scroll -= Math.floor(terminal.rows / 2);\n        terminal.scrollLines(scroll);\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Applies styles to the decoration when it is rendered.\n   * @param element The decoration's element.\n   * @param borderColor The border color to apply.\n   * @param isActiveResult Whether the element is part of the active search result.\n   * @returns\n   */\n  private _applyStyles(element: HTMLElement, borderColor: string | undefined, isActiveResult: boolean): void {\n    if (!element.classList.contains('xterm-find-result-decoration')) {\n      element.classList.add('xterm-find-result-decoration');\n      if (borderColor) {\n        element.style.outline = `1px solid ${borderColor}`;\n      }\n    }\n    if (isActiveResult) {\n      element.classList.add('xterm-find-active-result-decoration');\n    }\n  }\n\n  /**\n   * Creates a decoration for the result and applies styles\n   * @param result the search result for which to create the decoration\n   * @param options the options for the decoration\n   * @returns the {@link IDecoration} or undefined if the marker has already been disposed of\n   */\n  private _createResultDecoration(result: ISearchResult, options: ISearchDecorationOptions): IDecoration | undefined {\n    const terminal = this._terminal!;\n    const marker = terminal.registerMarker(-terminal.buffer.active.baseY - terminal.buffer.active.cursorY + result.row);\n    if (!marker) {\n      return undefined;\n    }\n    const findResultDecoration = terminal.registerDecoration({\n      marker,\n      x: result.col,\n      width: result.size,\n      backgroundColor: options.matchBackground,\n      overviewRulerOptions: this._highlightedLines.has(marker.line) ? undefined : {\n        color: options.matchOverviewRuler,\n        position: 'center'\n      }\n    });\n    if (findResultDecoration) {\n      const disposables: IDisposable[] = [];\n      disposables.push(marker);\n      disposables.push(findResultDecoration.onRender((e) => this._applyStyles(e, options.matchBorder, false)));\n      disposables.push(findResultDecoration.onDispose(() => dispose(disposables)));\n    }\n    return findResultDecoration;\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","globalThis","Object","defineProperty","value","Permutation","CallbackIterable","ArrayQueue","booleanComparator","numberComparator","CompareResult","tail","array","n","length","tail2","arr","Error","slice","equals","one","other","itemEquals","a","b","i","len","removeFastWithoutKeepingOrder","index","last","pop","binarySearch","key","comparator","binarySearch2","quickSelect","nth","data","compare","TypeError","pivotValue","Math","floor","random","lower","higher","pivots","val","push","groupBy","result","currentGroup","element","sort","groupAdjacentBy","items","shouldBeGrouped","item","undefined","forEachAdjacent","f","forEachWithNeighbors","sortedDiff","delta","before","after","splices","removed","added","splice","start","deleteCount","toInsert","top","topStep","topAsync","batch","token","Promise","resolve","reject","o","m","min","setTimeout","isCancellationRequested","errors_1","CancellationError","then","coalesce","filter","e","coalesceInPlace","to","move","from","isFalsyOrEmpty","obj","Array","isArray","isNonEmptyArray","distinct","keyFn","seen","Set","has","add","uniqueFilter","firstOrDefault","notFoundValue","lastOrDefault","commonPrefixLength","range","arg","indexer","mapper","reduce","r","t","create","insert","remove","arrayInsert","target","insertIndex","insertArr","concat","shuffle","_seed","rand","seed","x","sin","j","temp","pushToStart","indexOf","unshift","pushToEnd","pushMany","mapArrayOrNot","fn","map","asArray","getRandomElement","insertInto","newItems","getActualStartIndex","compareBy","selector","tieBreakComparators","comparators","item1","item2","isNeitherLessOrGreaterThan","neitherLessOrGreaterThan","reverseOrder","arraysFind_1","compareToKey","low","high","mid","comp","pushSplice","latest","beforeIdx","afterIdx","beforeElement","afterElement","findFirstIdxMonotonousOrArrLen","startIdx","originalLength","newItemsLength","max","isLessThan","isLessThanOrEqual","isGreaterThan","greaterThan","lessThan","constructor","this","firstIdx","lastIdx","takeWhile","predicate","takeFromEndWhile","endIdx","peek","peekLast","dequeue","removeLast","takeCount","count","empty","_callback","iterate","forEach","handler","toArray","cb","mapFn","some","findFirst","findLast","findLastMaxBy","first","_indexMap","createSortPermutation","compareFn","sortIndices","keys","index1","index2","apply","_","inverse","inverseIndexMap","findLastIdx","fromIndex","findLastIdxMonotonous","endIdxEx","k","MonotonousArray","idx","findLastMonotonous","findFirstMonotonous","findFirstIdxMonotonous","findFirstMax","findLastMax","findFirstMin","findMaxIdx","maxIdx","mapFindFirst","mapped","assertInvariants","_array","_findLastMonotonousLastIdx","_prevFindLastPredicate","_a","SetWithKey","groupFn","diffSets","diffMaps","intersection","setA","setB","elem","Symbol","toStringTag","values","toKey","_map","Map","size","set","delete","entries","entry","clear","callbackfn","thisArg","call","iterator","BugIndicatingError","ErrorNoTelemetry","ExpectedError","NotSupportedError","NotImplementedError","ReadonlyError","errorHandler","ErrorHandler","setUnexpectedErrorHandler","newUnexpectedErrorHandler","isSigPipeError","cast","code","syscall","toUpperCase","onUnexpectedError","isCancellationError","onUnexpectedExternalError","transformErrorForSerialization","error","name","message","$isError","stack","stacktrace","noTelemetry","isErrorNoTelemetry","transformErrorFromSerialization","canceled","canceledName","illegalArgument","illegalState","getErrorMessage","err","split","String","listeners","unexpectedErrorHandler","addListener","listener","_removeListener","emit","getUnexpectedErrorHandler","super","arguments","isExpected","msg","fromError","setPrototypeOf","prototype","ValueWithChangeEvent","Relay","EventBufferer","DynamicListEventMultiplexer","EventMultiplexer","MicrotaskEmitter","DebounceEmitter","PauseableEmitter","AsyncEmitter","createEventDeliveryQueue","Emitter","ListenerRefusalError","ListenerLeakError","EventProfiling","Event","setGlobalLeakWarningThreshold","oldValue","_globalLeakWarningThreshold","dispose","functional_1","lifecycle_1","linkedList_1","stopwatch_1","once","event","thisArgs","disposables","didFire","disposable","snapshot","emitter","onWillAddFirstListener","fire","onDidRemoveLastListener","debounce","merge","delay","leading","flushOnListenerRemove","leakWarningThreshold","subscription","output","handle","doFire","numDebouncedCalls","cur","_output","clearTimeout","queueMicrotask","onWillRemoveListener","None","Disposable","defer","each","signal","any","events","d","combinedDisposable","store","initial","accumulate","latch","cache","firstCall","shouldEmit","isT","buffer","flushAfterTimeout","_buffer","flush","onDidAddFirstListener","chain","sythensize","cs","ChainableSynthesis","evaluate","HaltChainable","steps","v","step","fromNodeEventEmitter","eventName","id","args","on","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","fromPromise","promise","res","finally","forward","runAndSubscribe","EmitterObserver","_observable","_counter","_hasChanged","options","addObserver","removeObserver","beginUpdate","handlePossibleChange","handleChange","_change","endUpdate","reportChanges","get","fromObservable","obs","fromObservableLight","observable","didChange","observer","DisposableStore","all","_idPool","listenerCount","invocationCount","elapsedOverall","durations","_stopWatch","StopWatch","stop","elapsed","LeakageMonitor","_errorHandler","threshold","toString","padStart","_warnCountdown","_stacks","check","topStack","topCount","getMostFrequentStack","console","warn","Stacktrace","print","join","UniqueContainer","_size","_options","_leakageMon","onListenerError","_perfMon","_profName","_deliveryQueue","deliveryQueue","_disposed","current","reset","_listeners","_event","callback","tuple","bind","contained","removeMonitor","ceil","EventDeliveryQueuePrivate","toDisposable","log","JSON","stringify","adjustDeliveryQueue","end","_deliver","_deliverQueue","dq","enqueue","hasListeners","fireAsync","promiseJoin","_asyncDeliveryQueue","LinkedList","l","forEachListener","shift","thenables","waitUntil","p","isFrozen","freeze","allSettled","status","reason","isPaused","_isPaused","_eventQueue","_mergeFn","pause","resume","_delay","_handle","_queuedEvents","onFirstListenerAdd","onLastListenerRemove","hook","createSingleCallFunction","unhook","onAddItem","onRemoveItem","getEvent","_store","multiplexer","itemListeners","DisposableMap","addItem","instance","deleteAndDispose","wrapEvent","buffers","reduceData","reducedResult","bufferEvents","listening","inputEvent","inputEventListener","input","ConstValueWithChangeEvent","_value","_onDidChange","onDidChange","fnDidRunCallback","_this","didCall","Iterable","is","thing","_empty","single","wrap","iterableOrElement","iterable","reverse","isEmpty","next","done","find","flatMap","iterables","reducer","initialValue","consume","atMost","Number","POSITIVE_INFINITY","consumed","asyncToArray","async","ImmortalReference","AsyncReferenceCollection","ReferenceCollection","SafeDisposable","RefCountedDisposable","MandatoryMutableDisposable","MutableDisposable","DisposableTracker","setDisposableTracker","tracker","disposableTracker","trackDisposable","markAsDisposed","markAsSingleton","singleton","isDisposable","disposeIfDisposable","parent","children","child","setParent","setParentOfDisposables","disposeOnReturn","arrays_1","collections_1","map_1","iterator_1","livingDisposables","getDisposableData","source","isSingleton","getRootParent","cacheValue","getTrackedDisposables","rootParentCache","computeLeakingDisposables","maxReported","preComputedLeaks","uncoveredLeakingObjs","leakingObjects","info","leakingObjsSet","getStackTracePath","leaking","lines","trim","replace","linesToRemove","regexp","match","removePrefix","stackTraceStarts","SetMap","stackTracePath","stackTraceFormattedLines","line","prevStarts","continuations","cont","leaks","details","setParentOfDisposable","errors","AggregateError","self","DISABLE_DISPOSED_WARNING","_toDispose","_isDisposed","isDisposed","deleteAndLeak","_register","clearAndLeak","_disposable","acquire","release","unset","isset","references","reference","counter","object","createReferencedObject","destroyReferencedObject","referenceCollection","ref","clearAndDisposeAll","skipDisposeOnOverwrite","Node","Undefined","prev","_first","_last","node","_insert","atTheEnd","newNode","oldLast","oldFirst","didRemove","_remove","anchor","Touch","BidirectionalMap","CounterSet","getOrSet","mapToString","setToString","mapsStrictEqualIgnoreOrder","_m1","_m2","getKey","hasPerformanceNow","performance","now","highResolution","_now","Date","_startTime","_stopTime","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","NON_WORD_CHARACTERS","SearchAddon","_highlightedLines","_highlightDecorations","_selectedDecoration","_linesCacheTimeoutId","_linesCacheDisposables","_onDidChangeResults","onDidChangeResults","_highlightLimit","highlightLimit","activate","terminal","_terminal","onWriteParsed","_updateMatches","onResize","clearDecorations","_highlightTimeout","window","_cachedSearchTerm","_lastSearchOptions","decorations","term","findPrevious","incremental","noScroll","retainCachedSearchTerm","clearActiveDecoration","findNext","searchOptions","didOptionsChanged","_didOptionsChange","_highlightAllMatches","found","_findNextAndSelect","_fireResults","searchResultsWithHighlight","prevResult","_find","row","col","cols","decoration","_createResultDecoration","marker","startRow","startCol","clearSelection","_initLinesCache","searchPosition","_findInLine","y","active","baseY","rows","prevSelectedPos","getSelectionPosition","_selectResult","_findPreviousAndSelect","lastSearchOptions","caseSensitive","regex","wholeWord","resultIndex","selectedMatch","resultCount","isReverseSearch","_linesCache","onLineFeed","_destroyLinesCache","onCursorMove","_isWholeWord","searchIndex","includes","firstLine","getLine","isWrapped","_translateBufferLineToStringWithWrap","stringLine","offsets","offset","_bufferColsToStringOffset","searchTerm","toLowerCase","searchStringLine","searchRegex","RegExp","foundTerm","exec","lastIndex","lastIndexOf","startRowOffset","endRowOffset","startColOffset","endColOffset","startColIndex","_stringLengthToBufferSize","cell","getCell","char","getChars","nextCell","getWidth","lineIndex","getCode","trimRight","strings","lineOffsets","nextLine","lineWrapsToNext","string","translateToString","lastCell","select","registerMarker","cursorY","registerDecoration","width","backgroundColor","activeMatchBackground","layer","overviewRulerOptions","color","activeMatchColorOverviewRuler","onRender","_applyStyles","activeMatchBorder","onDispose","viewportY","scroll","scrollLines","borderColor","isActiveResult","classList","contains","style","outline","findResultDecoration","matchBackground","matchOverviewRuler","position","matchBorder"],"sourceRoot":""}